<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2D-CFAR检测算法</title>
    <url>/2025/02/24/2D-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、内容复习"><a href="#一、内容复习" class="headerlink" title="一、内容复习"></a>一、内容复习</h2><p>CFAR检测算法属于信号检测中的自动检测算法，在雷达信号处理中主要应用的有三种，即CA-CFAR、SO-CFAR、GO-CFAR，这三种也是初学者最常采用的算法，要求每一个雷达工程师必须掌握其基本原理，如表所示，其中OS-CFAR一般不常用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CFAR 类型</th>
<th>参考电平 Z</th>
<th>适用场合</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>CA-CFAR</td>
<td>(X+Y)/2</td>
<td>均匀杂波背景</td>
<td>在杂波边缘会引起虚警率的上升；多目标环境中的检测性能较差。</td>
</tr>
<tr>
<td>SO-CFAR</td>
<td>min{X, Y}</td>
<td>在干扰目标位于前沿或后沿滑窗之一的多目标环境中能分辨出主目标。</td>
<td>杂波边缘和均匀杂波环境中的检测性能较差。</td>
</tr>
<tr>
<td>GO-CFAR</td>
<td>max{X, Y}</td>
<td>在杂波边缘和均匀杂波环境能保持较好的检测性能。</td>
<td>多目标环境中的检测性能较差。</td>
</tr>
<tr>
<td>OS-CFAR</td>
<td>(ascend_sort{X, Y})</td>
<td>多目标检测性能较好。</td>
<td>依赖于参考窗内的所有样本数据，且 k 的取值直接决定了检测结果的优劣。</td>
</tr>
</tbody>
</table>
</div>
<p>一维CFAR检测流程图如下所示</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9bdf49.png" alt="1d-cafr.png"></p>
<h2 id="二、距离多普勒矩阵（Range-Doppler-Matrix，RDM"><a href="#二、距离多普勒矩阵（Range-Doppler-Matrix，RDM" class="headerlink" title="二、距离多普勒矩阵（Range-Doppler Matrix，RDM)"></a>二、距离多普勒矩阵（Range-Doppler Matrix，RDM)</h2><p>在检测过程中，除了要知道到目标的距离信息以外，还要知道目标的速度信息，因此1D-CFAR不再满足我们的要求，而是需要采用2D-CAFR。而2D-CAFR处理的对象就是距离多普勒矩阵（Range-Doppler Matrix），RDM的形成过程如下所示</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d43961.png" alt="RDM.png"></p>
<p>2D-CFAR是对两个维度同时检测，</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9f14e8.png" alt="2d-cfar.png"></p>
<p>还有一种方法是两次CFAR，即先对某一个维度做一次，然后又对另一个维度做一次，总共两次CFAR。比如先对速度维做一次CA-CFAR，然后对距离维做一次OS-CFAR，如图7所示。这样做的目的可以减少计算量，节约计算时间。因为当检测出具有速度的目标后，只针对动目标检测要比检测全部元素点要快速。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9ed382.png" alt="2d-cfar2.png"></p>
<h2 id="三、二维CFAR（2D-CFAR）算法原理与仿真"><a href="#三、二维CFAR（2D-CFAR）算法原理与仿真" class="headerlink" title="三、二维CFAR（2D-CFAR）算法原理与仿真"></a>三、二维CFAR（2D-CFAR）算法原理与仿真</h2><p>前面阐述了一些概念性内容，下面是本文的核心部分。</p>
<p>如图所示，是2D-CFAR的原理模型。我们可以设计一个循环程序，通过在参考单元和保护单元的边缘提供边距，使 CUT 在距离多普勒图上滑动。对于每次迭代，求所有参考单元中所有信号电平的和并取平均。接下来，将 CUT （被检测单元）下的信号与此阈值进行比较。如果CUT &gt; 阈值，则认为是目标信号，并为其分配值 1，否则认为是噪声信号，并将其置为0。（类似神经网络里的conv2D有木有？）</p>
<p>上述过程将生成一个阈值块，如图中绿色和红色组成的区域。因为 CUT 不能位于RDM谱矩阵的边缘，故而该阈值块小于距离多普勒图， 因此存在一部分点不会被检测到，但需要对这部分未检测到的点进行处理，关于这个问题后面会讨论。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d42c23.png" alt="2d-cfar3.png"></p>
<h2 id="四、仿真"><a href="#四、仿真" class="headerlink" title="四、仿真"></a>四、仿真</h2><ol>
<li>生成FMCW信号</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% FMCW 波形生成</span></span><br><span class="line"></span><br><span class="line">B = c /(<span class="number">2</span>*range_resolution);       <span class="comment">%带宽</span></span><br><span class="line">Tchirp= (<span class="number">5.5</span>*<span class="number">2</span>*max_range)/c;       <span class="comment">%计算 Chirp 时间（5.5 倍往返时间）</span></span><br><span class="line">slope = B/Tchirp;                  <span class="comment">%FMCW斜率</span></span><br><span class="line"><span class="built_in">disp</span>(slope);                       <span class="comment">% 显示斜率</span></span><br><span class="line">fc= <span class="number">1.5e3</span>;                         <span class="comment">%载波频率</span></span><br><span class="line">                                                          </span><br><span class="line"><span class="comment">% 一组 Chirp 信号的数量（建议使用 2 的幂次方以便 FFT 计算多普勒频谱）</span></span><br><span class="line">Nd=<span class="number">128</span>;                            <span class="comment">% 多普勒维度（即 Chirp 数量）</span></span><br><span class="line"><span class="comment">%每个chirp的采样数</span></span><br><span class="line">Nr=<span class="number">1024</span>;                           <span class="comment">% 距离维度（即每个 Chirp 的采样点数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 时间向量，覆盖所有 Chirp 和每个 Chirp 内的样本</span></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,Nd*Tchirp,Nr*Nd);     <span class="comment">% 生成总时间轴</span></span><br></pre></td></tr></table></figure>
<ol>
<li>信号生成与移动目标仿真</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(t)         </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% *%TODO* :</span></span><br><span class="line">    <span class="comment">% 根据时间步长更新目标的距离 (匀速运动)</span></span><br><span class="line">    <span class="comment">% r(t) = r0 + v*t</span></span><br><span class="line">    r_t(<span class="built_in">i</span>) = target_range+ target_velocity*t(<span class="built_in">i</span>); <span class="comment">% 目标当前距离</span></span><br><span class="line">    td(<span class="built_in">i</span>) = <span class="number">2</span>*r_t(<span class="built_in">i</span>)/c;                          <span class="comment">% 计算信号往返时间延迟</span></span><br><span class="line">    <span class="comment">% <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">% 为每个时间点生成发射和接收信号</span></span><br><span class="line">    <span class="comment">% 发射信号 Tx：FMCW 信号的基本公式</span></span><br><span class="line">    Tx(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(fc*t(<span class="built_in">i</span>) + (slope*t(<span class="built_in">i</span>)^<span class="number">2</span>)/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 接收信号 Rx：考虑了往返延迟的 FMCW 信号</span></span><br><span class="line">    Rx(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(fc*(t(<span class="built_in">i</span>)-td(<span class="built_in">i</span>)) + (slope*(t(<span class="built_in">i</span>)-td(<span class="built_in">i</span>))^<span class="number">2</span>)/<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">% 生成混频信号（打拍频信号）</span></span><br><span class="line">    <span class="comment">% 将发射信号和接收信号逐元素相乘</span></span><br><span class="line">    Mix(<span class="built_in">i</span>) = Tx(<span class="built_in">i</span>).*Rx(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>距离-多普勒响应 (RDM)</strong></p>
<p>该部分实现了 2D FFT，用于生成距离-多普勒图 (RDM)。 后续可以基于该 RDM 进行 CFAR 检测。</p>
</li>
</ol>
<p>二维 FFT 的输出是一个包含距离和多普勒频移响应的图像，其坐标轴单位最初是FFT bin（频率单元格）。 因此，为了直观反映目标的实际距离和速度， 需要根据最大取值将坐标轴从 bin 索引转换为实际的距离 (m) 和多普勒速度 (m/s)。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 将混频信号重塑为 Nr × Nd 矩阵</span></span><br><span class="line">Mix=<span class="built_in">reshape</span>(Mix,[Nr,Nd]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对打拍频信号执行二维 FFT（分别在距离和多普勒维度上）</span></span><br><span class="line">sig_fft2 = fft2(Mix,Nr,Nd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 仅保留距离维度的单边谱</span></span><br><span class="line">sig_fft2 = sig_fft2(<span class="number">1</span>:Nr/<span class="number">2</span>,<span class="number">1</span>:Nd);</span><br><span class="line"></span><br><span class="line">sig_fft2 = fftshift(sig_fft2);<span class="comment">% 对多普勒维度做 fftshift，使零频分量居中</span></span><br><span class="line">RDM = <span class="built_in">abs</span>(sig_fft2);        <span class="comment">% 计算幅度并转换为 dB 值</span></span><br><span class="line">RDM = <span class="number">10</span>*<span class="built_in">log10</span>(RDM) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">% ---------------------</span></span><br><span class="line"><span class="comment">% 绘制距离-多普勒图 (RDM)</span></span><br><span class="line"><span class="comment">% ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义多普勒和距离坐标轴</span></span><br><span class="line">doppler_axis = <span class="built_in">linspace</span>(<span class="number">-100</span>,<span class="number">100</span>,Nd);             <span class="comment">% 多普勒频移轴（-100 ~ 100 m/s）</span></span><br><span class="line">range_axis = <span class="built_in">linspace</span>(<span class="number">-200</span>,<span class="number">200</span>,Nr/<span class="number">2</span>)*((Nr/<span class="number">2</span>)/<span class="number">400</span>);<span class="comment">% 距离轴</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">surf(doppler_axis,range_axis,RDM);</span><br><span class="line">xlabel(<span class="string">&#x27;doppler&#x27;</span>);ylabel(<span class="string">&#x27;range&#x27;</span>);zlabel(<span class="string">&#x27;RDM&#x27;</span>);title(<span class="string">&#x27;2D FFT&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>CFAR 检测</strong></li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%在RDM上窗口滑动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择训练单元 (Training Cells) 的数量</span></span><br><span class="line">Tr = <span class="number">8</span>; <span class="comment">% 距离维度上的训练单元数量</span></span><br><span class="line">Td = <span class="number">4</span>; <span class="comment">% 多普勒维度上的训练单元数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择保护单元 (Guard Cells) 的数量，围绕 CUT 以避免信号泄漏</span></span><br><span class="line">Gr = <span class="number">4</span>; <span class="comment">% 距离维度上的保护单元数量</span></span><br><span class="line">Gd = <span class="number">2</span>; <span class="comment">% 多普勒维度上的保护单元数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">% 设置SNR偏移量 (以dB为单位)，用于调整检测灵敏度</span></span><br><span class="line">offset = <span class="number">1.4</span>;</span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">%初始化一个向量来存储训练单元每个 iteration 的噪声级</span></span><br><span class="line">noise_level = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">% 设计一个循环，使 “CUT” 在距离 - 多普勒图上滑动，同时在边缘处为训练单元和保护单元留出边界。</span></span><br><span class="line"><span class="comment">% 对于每次迭代，将所有训练单元内的信号电平进行求和。为了求和，需使用 db2pow 函数将数值从对数形式转换为线性形式。</span></span><br><span class="line"><span class="comment">% 对所使用的所有训练单元的求和值求平均。求平均后，再使用 pow2db 函数将其转换回对数形式。</span></span><br><span class="line"><span class="comment">% 进一步给它加上偏移量以确定阈值。接下来，将 “CUT” 下的信号与该阈值进行比较。</span></span><br><span class="line"><span class="comment">% 如果 “CUT” 的电平 &gt; 阈值，则赋予其值为 1，否则将其设为 0。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">% Use RDM[x,y] as the matrix from the output of 2D FFT for implementing</span></span><br><span class="line">   <span class="comment">% CFAR</span></span><br><span class="line"></span><br><span class="line">RDM = RDM/<span class="built_in">max</span>(<span class="built_in">max</span>(RDM));</span><br><span class="line"> <span class="comment">%滑动窗口遍历整个RDM</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = Tr+Gr+<span class="number">1</span> : Nr/<span class="number">2</span>-(Gr+Tr)    <span class="comment">% 遍历距离维度</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = Td+Gd+<span class="number">1</span> : Nd-(Gd+Td)  <span class="comment">% 遍历多普勒维度</span></span><br><span class="line"></span><br><span class="line">        noise_level = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">1</span>);  <span class="comment">% 初始化当前窗口的噪声能量</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> p = <span class="built_in">i</span>-(Tr+Gr): <span class="built_in">i</span>+ (Tr+Gr) <span class="comment">% 遍历当前CUT周围的训练单元和保护单元</span></span><br><span class="line">            <span class="keyword">for</span> q = <span class="built_in">j</span>-(Td+Gd): <span class="built_in">j</span>+(Td+Gd)</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">i</span>-p)&gt; Gr ||<span class="built_in">abs</span>(<span class="built_in">j</span>-q)&gt;Gd)<span class="comment">% 排除保护单元，只计算训练单元的能量</span></span><br><span class="line">                   <span class="comment">% 将dB值转换为线性功率值</span></span><br><span class="line">                    noise_level = noise_level+ db2pow(RDM(p,q));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 平均训练单元能量并转换回dB</span></span><br><span class="line">        threshold = pow2db(noise_level/(<span class="number">2</span>*(Td+Gd+<span class="number">1</span>)*<span class="number">2</span>*(Tr+Gr+<span class="number">1</span>)-(Gr*Gd)<span class="number">-1</span>));</span><br><span class="line">        threshold = threshold + offset;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 进行检测：若CUT大于阈值，标记为目标（1），否则为噪声（0）</span></span><br><span class="line">        CUT= RDM(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">if</span> (CUT&lt;threshold)</span><br><span class="line">            RDM(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            RDM(<span class="built_in">i</span>,<span class="built_in">j</span>)= <span class="number">1</span>; <span class="comment">% max_T</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line">            <span class="built_in">disp</span>(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 上述过程将生成一个经过阈值处理的块，该块比距离 - 多普勒图小，</span></span><br><span class="line"><span class="comment">% 因为 “CUT” 不能位于矩阵的边缘。因此，有少量单元不会经过阈值处理。</span></span><br><span class="line"><span class="comment">% 为了保持地图大小不变，将这些单元的值设为 0。</span></span><br><span class="line"></span><br><span class="line">RDM(RDM~=<span class="number">0</span> &amp; RDM~=<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">%RDM(union(1:(Tr+Gr),end-(Tr+Gr-1):end),:) = 0;  % Rows</span></span><br><span class="line"><span class="comment">%RDM(:,union(1:(Td+Gd),end-(Td+Gd-1):end)) = 0;  % Columns</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">%绘制CFAR输出</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;CFAR&#x27;</span>)</span><br><span class="line">surf(doppler_axis,range_axis,RDM);</span><br><span class="line">colorbar;</span><br><span class="line">title(<span class="string">&#x27;offset 1.4&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后续内容待补充……</p>
<p>完整代码：<a href="https://github.com/Vanillaholic/2D-CFAR-detection-of-FMCW">https://github.com/Vanillaholic/2D-CFAR-detection-of-FMCW</a></p>
<p>(本文只是学习笔记，侵删)参考：</p>
<p>[1] <a href="https://mp.weixin.qq.com/s/Gs8xTeQt5dtY8jMBfZ2xYA">https://mp.weixin.qq.com/s/Gs8xTeQt5dtY8jMBfZ2xYA</a></p>
<p>[2] <a href="https://mp.weixin.qq.com/s/iC18AWIRj6jOnR8SJMbpZw">https://mp.weixin.qq.com/s/iC18AWIRj6jOnR8SJMbpZw</a><br><!--stackedit_data:
eyJoaXN0b3J5IjpbMjc5NjAyMDE1XX0=
--></p>
]]></content>
      <categories>
        <category>信号处理</category>
        <category>CFAR</category>
      </categories>
      <tags>
        <tag>雷达/声纳</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Acoustic Toolbox和Arlpy配置</title>
    <url>/2025/07/03/Acoustic%20Toolbox%E5%92%8CArlpy%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>python的arlpy包是调用Acoustic Toolbox中的fortran进行仿真计算，首先需要下载Acoustic Toolbox</p>
<h3 id="下载Acoustic-Toolbox"><a href="#下载Acoustic-Toolbox" class="headerlink" title="下载Acoustic Toolbox"></a>下载Acoustic Toolbox</h3><p>下载链接：</p>
<ul>
<li><a href="http://oalib.hlsresearch.com/AcousticsToolbox/at_2024_12_25.zip">http://oalib.hlsresearch.com/AcousticsToolbox/at_2024_12_25.zip</a>  （Mac/Linux/Windows – 必须要手动进行编译）</li>
<li><a href="http://oalib.hlsresearch.com/AcousticsToolbox/atWin10_2020_11_4.zip">http://oalib.hlsresearch.com/AcousticsToolbox/atWin10_2020_11_4.zip</a>  （旧版本，涵盖了MATLAB I/O）</li>
</ul>
<h3 id="下载后，将工具包解压，打开命令行，进行配置"><a href="#下载后，将工具包解压，打开命令行，进行配置" class="headerlink" title="下载后，将工具包解压，打开命令行，进行配置"></a>下载后，将工具包解压，打开命令行，进行配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> at/at  			<span class="comment">#访问解压文件所在路径</span></span><br><span class="line">make clean 			<span class="comment">#清除之前的编译文件</span></span><br><span class="line">make all  			<span class="comment">#进行编译</span></span><br><span class="line"><span class="built_in">sudo</span> make install   <span class="comment">#安装</span></span><br></pre></td></tr></table></figure>
<p>（这里可能会因为电脑操作系统不同产生报错,需要修改makefile文件)</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202507031310234.png" alt="makefile"></p>
<p>如果是Mac电脑，将makefile替换成以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These lines are used under Mac OSX; the syntax is different under Windows</span></span><br><span class="line"><span class="comment"># !!!!!!! You also need to use xiar instead of ar</span></span><br><span class="line"><span class="comment"># That change needs to be made in at/misc/Makefile and at/tslib/Makefile</span></span><br><span class="line"><span class="comment"># Note that the -assume byterecl is important, otherwise the output files have the wrong format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you use the -parallel option, the compiler links into a dynamic library for OpenMP</span></span><br><span class="line"><span class="comment"># Then you need to make sure that dylib is in the path</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the best architecture (target machine) using the -x switch</span></span><br><span class="line"><span class="comment"># According to the latest benchmarks on polyhedron, it looks like -parallel is very helpful</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># need -heap-arrays to avoid stack overflows for big runs ...</span></span><br><span class="line"><span class="comment"># -no-wrap-margin was added to avoid ascii arrival files being wrapped at 80 characters</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> FC=ifort</span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -parallel -axSSE4.2 -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS= -fast -axAVX                           -parallel              -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -axAVX              -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -axAVX              -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -xHost -qopt-report -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -xHost              -funroll-loops           -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -no-wrap-margin</span><br><span class="line"></span><br><span class="line"><span class="comment"># recommended settings from POLYHEDRON site</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast           -ipo -nostandard-realloc-lhs</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -nostandard-realloc-lhs</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -no-prec-div                                       -assume byterecl -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -no-prec-div -qopt-report-phase=par -qopt-report:5 -assume byterecl -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -nologo                                               -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -ipo -funroll-loops -xAVX -no-prec-div -axAVX -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -nostandard-realloc-lhs -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -check -traceback</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast           -ipo -nostandard-realloc-lhs -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -check -traceback</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime diagnostics on as well:</span></span><br><span class="line"><span class="comment">#export FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all -ftrapuv -fpe0 -gen-interfaces -traceback</span></span><br><span class="line"><span class="comment">#export FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all -ftrapuv                       -traceback -check noarg_temp_created</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all                                -traceback -check noarg_temp_created</span><br><span class="line"></span><br><span class="line"><span class="comment"># profiling:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -g -O3 -profile-functions -profile-loops=all -xHost -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -traceback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########export FFLAGS+= -I/opt/intel/compilers_and_libraries_2018.2.164/mac/compiler/lib/libiomp5.dylib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** GNU Compiler Collection GFORTRAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use -march=generic if you get warning messages about instructions that don&#x27;t make sense</span></span><br><span class="line"><span class="comment"># -march=generic assumes an old Intel architecture that the newer versions can all execute (slowly)</span></span><br><span class="line"><span class="comment"># -march=native should normally be the best; however, it produced AVX instructions on the Mac that the default assembler could not process</span></span><br><span class="line"><span class="comment"># -O2 was the highest level of optimization that worked under Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -static can be used to tell gfortran not to rely on a dynamic link library (the compiler may or may not support)</span></span><br><span class="line"><span class="comment"># -static does not seem to work on Macs though, and produces larger executables</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Have had various problems where some installed dynamic link library is incompatible with the one the compiler used and expects at run time</span></span><br><span class="line"><span class="comment"># For instance, Matlab changes paths and may point to an incompatible library.</span></span><br><span class="line"><span class="comment"># One user found that it was necessary to delete /usr/local/gfortran/lib/libquadmath.dylib to force a static link. See:</span></span><br><span class="line"><span class="comment"># http://stackoverflow.com/questions/17590525/correct-way-to-statically-link-in-gfortran-libraries-on-osx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -Wa,-q flag can be used to select the Mac CLANG assembler instead of the GNU assembler</span></span><br><span class="line"><span class="comment"># At one time that was necessary to get the AVX operations; however, I saw no speed benefit</span></span><br><span class="line"><span class="comment"># -march=corei7-avx works on my Mac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> FC=gfortran</span><br><span class="line"></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native  -Wall -std=gnu -O3 -ffast-math -funroll-all-loops -msse3 -fomit-frame-pointer -mtune=native -Q</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=corei7 -Bstatic -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation       -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span></span><br><span class="line"><span class="comment"># -L/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr/lib</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=corei7 -Bstatic -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation        -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native          -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation -Wa,-q -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span></span><br><span class="line"><span class="comment"># Had a problem with -O2 in the KRAKENC root finder for at/tests/Noise/Sduct. Switching to O1 (4//25/2023)</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS= -march=native -Bstatic -Waliasing -Wampersand              -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation         -std=gnu  -O1 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation and run-time diagnostics on:</span></span><br><span class="line"><span class="comment"># omni.env fails trap=invalid</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native -ffpe-trap=invalid,zero,overflow -Wall                  -std=gnu -O1 -fcheck=all -fbacktrace</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native -ffpe-trap=zero,overflow         -Wall                  -std=gnu -O1 -fcheck=all -fbacktrace</span></span><br><span class="line"><span class="comment">#export FFLAGS= -march=native -ffpe-trap=zero,overflow         -Wall -pedantic-errors -std=gnu -O1 -fcheck=all -fbacktrace -finit-real=nan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Profiling:</span></span><br><span class="line"><span class="comment"># I read that the -pg flag is needed for profiling, but there&#x27;s some problem with the library and it doesn&#x27;t compile</span></span><br><span class="line"><span class="comment"># It does compile with just the -p and -g flags but does not appear to have enough info for the xcode instruments</span></span><br><span class="line"><span class="comment"># export FFLAGS= -p -g -pg -march=native -Wall -std=gnu</span></span><br><span class="line"><span class="comment"># export FFLAGS= -p -g -march=native -Bstatic -Wa,-q -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation -std=gnu -O3 -ffast-math -funroll-all-loops -fcheck=all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** g95</span></span><br><span class="line"><span class="comment"># This is no longer working with the Acoustics Toolbox because it uses Fortran features that the g95 compiler has not implemented</span></span><br><span class="line"><span class="comment"># export FC=g95</span></span><br><span class="line"><span class="comment"># export FFLAGS = -Wall -std=f2003 -O3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS = -Wall -std=f2003 -ftrace=full -fbounds-check</span></span><br><span class="line"><span class="comment"># export FFLAGS = -pg   -std=f2003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** Portland Group FORTRAN</span></span><br><span class="line"><span class="comment"># -Mnoframe caused erroneous results</span></span><br><span class="line"><span class="comment"># -Munroll  caused erroneous results</span></span><br><span class="line"><span class="comment"># These are defaults under -fast, so can&#x27;t use -fast either</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export FC=pgfortran</span></span><br><span class="line"><span class="comment"># export FFLAGS= -Mconcur</span></span><br><span class="line"><span class="comment"># export FFLAGS= -fast</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O2 -Munroll=c:1 -Mnoframe -Mlre -Mpre -Mvect=sse -Mcache_align -Mflushz -Mvect</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O2 -Mlre -Mpre -Mvect=sse -Mcache_align -Mflushz -Mvect</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -g -Minfo=ccff -Minform=inform -C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> RM=<span class="built_in">rm</span></span><br><span class="line"><span class="built_in">export</span> CC=gcc</span><br><span class="line"><span class="built_in">export</span> CFLAGS=-g</span><br><span class="line"><span class="comment">#export FFLAGS+= -I../misc -I../tslib -I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS+= -I../misc -I../tslib</span><br><span class="line"></span><br><span class="line"><span class="comment"># KRAKEL is commented out below because it requires the LAPACK library.</span></span><br><span class="line"><span class="comment"># If you have the LAPACK library installed on your system, first edit the</span></span><br><span class="line"><span class="comment"># LAPACK_LIBS variable below to point to your installation, then you can</span></span><br><span class="line"><span class="comment"># uncomment the make commands below (uncomment both the &quot;all&quot; and &quot;install&quot;</span></span><br><span class="line"><span class="comment"># targets).</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LAPACK_LIBS = -llapack</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;	make -k all)</span><br><span class="line">	<span class="comment"># (cd Krakel;	make -k all)</span></span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k all)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***********************************&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***** Acoustics Toolbox built *****&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***********************************&quot;</span></span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k install)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k install)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;        make -k install)</span><br><span class="line">	<span class="comment"># (cd Krakel;	make -k install)</span></span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k install)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***************************************&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***** Acoustics Toolbox installed *****&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***************************************&quot;</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	-<span class="built_in">rm</span> -f bin/*.exe</span><br><span class="line">	find . -name <span class="string">&#x27;*.dSYM&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.png&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.eps&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.mod&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.grn&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.shd&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.shd.mat&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.prt&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Krakel;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> tests;	make -k -i clean)</span><br></pre></td></tr></table></figure>
<p>如果是Linux操作内核，替换成以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To install the Acoustics Toolbox:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Uncomment the appropriate lines below to select your FORTRAN compiler</span></span><br><span class="line"><span class="comment">#    (also be sure to comment out all of the lines corresponding to the other compilers).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) If you&#x27;re using gfortran check the -march switch that selects the chip you&#x27;re using.</span></span><br><span class="line"><span class="comment">#    Usually -march=native works</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) From a command line shell, run:</span></span><br><span class="line"><span class="comment">#    % make clean</span></span><br><span class="line"><span class="comment">#    % make</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># on some machines you need to say -mcmodel=medium (or large) to allow for variables larger than 2 gig</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** Windows ***</span></span><br><span class="line"><span class="comment"># If you don&#x27;t have a FORTRAN compiler, the MinGW (&quot;Minimalist GNU for Windows&quot;) compiler suite</span></span><br><span class="line"><span class="comment"># is a good choice as it is much easier to install than Cygwin. See http://www.mingw.org/ for details.</span></span><br><span class="line"><span class="comment"># Not sure if this is still necessary, but we used to have to change the options -O3 to -O2 below when using gfortran</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** Linux ***</span></span><br><span class="line"><span class="comment"># Most Linux distributions have gfortran already packaged and it can be installed with the respective </span></span><br><span class="line"><span class="comment"># package manager (e.g. apt-get, dnf, yum). The packaged versions of the LAPACK library are generally</span></span><br><span class="line"><span class="comment"># compatible with Krakel. If you want statically linked executables, &quot;-static&quot; works with gfortran.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** Mac ***</span></span><br><span class="line"><span class="comment"># The option to create an executable that uses a static library has been a problem.</span></span><br><span class="line"><span class="comment"># The gcc community seems to feel that dynamic vs. static libraries is an issue of religious importance.</span></span><br><span class="line"><span class="comment"># I prefer static libraries because users have a lot fewer problems installing the code when they don&#x27;t have</span></span><br><span class="line"><span class="comment"># to worry about getting the LD_LIBRARY_PATH set, or the fact that some programs (e.g. Matlab) may reset</span></span><br><span class="line"><span class="comment"># that path to an incompatible version.</span></span><br><span class="line"><span class="comment"># -static is supposed to work if gfortran has been compiled to enable that option.</span></span><br><span class="line"><span class="comment"># However, crt0.o comes up as misssing</span></span><br><span class="line"><span class="comment"># -Bstatic worked</span></span><br><span class="line"><span class="comment"># You may need to specify an architecture flag under gfortran:</span></span><br><span class="line"><span class="comment"># -march=native ( for M2 processor)</span></span><br><span class="line"><span class="comment"># -mcpu=ARMv8.6-A ( for generic ARM processor instruction sets)</span></span><br><span class="line"><span class="comment"># For further info, see https://oalib-acoustics.org/website_resources/AcousticsToolbox/AT_compile_mac_linux.html</span></span><br><span class="line"><span class="comment"># 11/27/2023:</span></span><br><span class="line"><span class="comment"># A user reported issues with security on the HPC binary files. Apparently some of the downloaded files were quarantined by the Mac OS</span></span><br><span class="line"><span class="comment"># and needed fixing using the xattr command</span></span><br><span class="line"><span class="comment"># Also a user noted that Xcor developer tools are not needed. Apparently the Command Line Tools are sufficient.</span></span><br><span class="line"><span class="comment"># A user reported that the warning messages produced when running the Makefile were confusing, but that the compiled code worked anyway.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The make utility tends to get confused with modules because it does not necessarily update the *.mod file</span></span><br><span class="line"><span class="comment"># when it compiles the *.f90 file. (The *.mod file contains interface information that doesn&#x27;t necessarily change</span></span><br><span class="line"><span class="comment"># even when the *.f90 file has changed.)</span></span><br><span class="line"><span class="comment"># As a result, you may find that make keeps compiling a module, that was already compiled.</span></span><br><span class="line"><span class="comment"># A &#x27;make clean&#x27; will fix that</span></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** ifort</span></span><br><span class="line"><span class="comment"># These lines are used under Mac OSX; the syntax is different under Windows</span></span><br><span class="line"><span class="comment"># !!!!!!! You also need to use xiar instead of ar</span></span><br><span class="line"><span class="comment"># That change needs to be made in at/misc/Makefile and at/tslib/Makefile</span></span><br><span class="line"><span class="comment"># Note that the -assume byterecl is important, otherwise the output files have the wrong format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If you use the -parallel option, the compiler links into a dynamic library for OpenMP</span></span><br><span class="line"><span class="comment"># Then you need to make sure that dylib is in the path</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the best architecture (target machine) using the -x switch</span></span><br><span class="line"><span class="comment"># According to the latest benchmarks on polyhedron, it looks like -parallel is very helpful</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># need -heap-arrays to avoid stack overflows for big runs ...</span></span><br><span class="line"><span class="comment"># -no-wrap-margin was added to avoid ascii arrival files being wrapped at 80 characters</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> FC=ifort</span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -parallel -axSSE4.2 -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS= -fast -axAVX                           -parallel              -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -axAVX              -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -axAVX              -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -xHost -qopt-report -funroll-loops -parallel -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span><br><span class="line"><span class="built_in">export</span> FFLAGS= -O3 -xHost              -funroll-loops           -no-prec-div -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -no-wrap-margin</span><br><span class="line"></span><br><span class="line"><span class="comment"># recommended settings from POLYHEDRON site</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast           -ipo -nostandard-realloc-lhs</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -nostandard-realloc-lhs</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -no-prec-div                                       -assume byterecl -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -no-prec-div -qopt-report-phase=par -qopt-report:5 -assume byterecl -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -nologo                                               -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -ipo -funroll-loops -xAVX -no-prec-div -axAVX -nologo -inline-level=2 -assume byterecl -threads -heap-arrays</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast -parallel -ipo -nostandard-realloc-lhs -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -check -traceback</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O3 -fast           -ipo -nostandard-realloc-lhs -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -check -traceback</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime diagnostics on as well:</span></span><br><span class="line"><span class="comment">#export FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all -ftrapuv -fpe0 -gen-interfaces -traceback</span></span><br><span class="line"><span class="comment">#export FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all -ftrapuv                       -traceback -check noarg_temp_created</span></span><br><span class="line"><span class="comment">#export FFLAGS= -nologo     -inline-level=2 -assume byterecl -threads -heap-arrays -check all                                -traceback -check noarg_temp_created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># profiling:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -g -O3 -profile-functions -profile-loops=all -xHost -nologo -inline-level=2 -assume byterecl -threads -heap-arrays -traceback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########export FFLAGS+= -I/opt/intel/compilers_and_libraries_2018.2.164/mac/compiler/lib/libiomp5.dylib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** GNU Compiler Collection GFORTRAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use -march=generic if you get warning messages about instructions that don&#x27;t make sense</span></span><br><span class="line"><span class="comment"># -march=generic assumes an old Intel architecture that the newer versions can all execute (slowly)</span></span><br><span class="line"><span class="comment"># -march=native should normally be the best; however, it produced AVX instructions on the Mac that the default assembler could not process</span></span><br><span class="line"><span class="comment"># -O2 was the highest level of optimization that worked under Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -static can be used to tell gfortran not to rely on a dynamic link library (the compiler may or may not support)</span></span><br><span class="line"><span class="comment"># -static does not seem to work on Macs though, and produces larger executables</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Have had various problems where some installed dynamic link library is incompatible with the one the compiler used and expects at run time</span></span><br><span class="line"><span class="comment"># For instance, Matlab changes paths and may point to an incompatible library.</span></span><br><span class="line"><span class="comment"># One user found that it was necessary to delete /usr/local/gfortran/lib/libquadmath.dylib to force a static link. See:</span></span><br><span class="line"><span class="comment"># http://stackoverflow.com/questions/17590525/correct-way-to-statically-link-in-gfortran-libraries-on-osx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The -Wa,-q flag can be used to select the Mac CLANG assembler instead of the GNU assembler</span></span><br><span class="line"><span class="comment"># At one time that was necessary to get the AVX operations; however, I saw no speed benefit</span></span><br><span class="line"><span class="comment"># -march=corei7-avx works on my Mac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> FC=gfortran</span><br><span class="line"></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native  -Wall -std=gnu -O3 -ffast-math -funroll-all-loops -msse3 -fomit-frame-pointer -mtune=native -Q</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=corei7 -Bstatic -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation       -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span></span><br><span class="line"><span class="comment"># -L/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr/lib</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=corei7 -Bstatic -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation        -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native          -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation -Wa,-q -std=f2008 -O3 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span></span><br><span class="line"><span class="comment"># Had a problem with -O2 in the KRAKENC root finder for at/tests/Noise/Sduct. Switching to O1 (4//25/2023)</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native -Bstatic -Waliasing -Wampersand              -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation         -std=gnu  -O1 -ffast-math -funroll-all-loops -fomit-frame-pointer -mtune=native</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS= -march=native -Bstatic -Waliasing -Wampersand              -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation         -std=gnu  -O1 -ffast-math -funroll-all-loops -fomit-frame-pointer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation and run-time diagnostics on:</span></span><br><span class="line"><span class="comment"># omni.env fails trap=invalid</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native -ffpe-trap=invalid,zero,overflow -Wall                  -std=gnu -O1 -fcheck=all -fbacktrace</span></span><br><span class="line"><span class="comment"># export FFLAGS= -march=native -ffpe-trap=zero,overflow         -Wall                  -std=gnu -O1 -fcheck=all -fbacktrace</span></span><br><span class="line"><span class="comment">#export FFLAGS= -march=native -ffpe-trap=zero,overflow         -Wall -pedantic-errors -std=gnu -O1 -fcheck=all -fbacktrace -finit-real=nan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Profiling:</span></span><br><span class="line"><span class="comment"># I read that the -pg flag is needed for profiling, but there&#x27;s some problem with the library and it doesn&#x27;t compile</span></span><br><span class="line"><span class="comment"># It does compile with just the -p and -g flags but does not appear to have enough info for the xcode instruments</span></span><br><span class="line"><span class="comment"># export FFLAGS= -p -g -pg -march=native -Wall -std=gnu</span></span><br><span class="line"><span class="comment"># export FFLAGS= -p -g -march=native -Bstatic -Wa,-q -Waliasing -Wampersand -Wsurprising -Wintrinsics-std -Wno-tabs -Wintrinsic-shadow -Wline-truncation -std=gnu -O3 -ffast-math -funroll-all-loops -fcheck=all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** g95</span></span><br><span class="line"><span class="comment"># This is no longer working with the Acoustics Toolbox because it uses Fortran features that the g95 compiler has not implemented</span></span><br><span class="line"><span class="comment"># export FC=g95</span></span><br><span class="line"><span class="comment"># export FFLAGS = -Wall -std=f2003 -O3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS = -Wall -std=f2003 -ftrace=full -fbounds-check</span></span><br><span class="line"><span class="comment"># export FFLAGS = -pg   -std=f2003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *** Portland Group FORTRAN</span></span><br><span class="line"><span class="comment"># -Mnoframe caused erroneous results</span></span><br><span class="line"><span class="comment"># -Munroll  caused erroneous results</span></span><br><span class="line"><span class="comment"># These are defaults under -fast, so can&#x27;t use -fast either</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export FC=pgfortran</span></span><br><span class="line"><span class="comment"># export FFLAGS= -Mconcur</span></span><br><span class="line"><span class="comment"># export FFLAGS= -fast</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O2 -Munroll=c:1 -Mnoframe -Mlre -Mpre -Mvect=sse -Mcache_align -Mflushz -Mvect</span></span><br><span class="line"><span class="comment"># export FFLAGS= -O2 -Mlre -Mpre -Mvect=sse -Mcache_align -Mflushz -Mvect</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compilation diagnostics on:</span></span><br><span class="line"><span class="comment"># export FFLAGS= -g -Minfo=ccff -Minform=inform -C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ______________________________________________________________________________</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> RM=<span class="built_in">rm</span></span><br><span class="line"><span class="built_in">export</span> CC=gcc</span><br><span class="line"><span class="built_in">export</span> CFLAGS=-g</span><br><span class="line"><span class="comment">#export FFLAGS+= -I../misc -I../tslib -I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</span></span><br><span class="line"><span class="built_in">export</span> FFLAGS+= -I../misc -I../tslib</span><br><span class="line"></span><br><span class="line"><span class="comment"># KRAKEL is commented out below because it requires the LAPACK library.</span></span><br><span class="line"><span class="comment"># If you have the LAPACK library installed on your system, first edit the</span></span><br><span class="line"><span class="comment"># LAPACK_LIBS variable below to point to your installation, then you can</span></span><br><span class="line"><span class="comment"># uncomment the make commands below (uncomment both the &quot;all&quot; and &quot;install&quot;</span></span><br><span class="line"><span class="comment"># targets).</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LAPACK_LIBS = -llapack</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;	make -k all)</span><br><span class="line">	<span class="comment"># (cd Krakel;	make -k all)</span></span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k all)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***********************************&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***** Acoustics Toolbox built *****&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***********************************&quot;</span></span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k all)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k install)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k install)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;        make -k install)</span><br><span class="line">	<span class="comment"># (cd Krakel;	make -k install)</span></span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k install)</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot; &quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***************************************&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***** Acoustics Toolbox installed *****&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;***************************************&quot;</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	-<span class="built_in">rm</span> -f bin/*.exe</span><br><span class="line">	find . -name <span class="string">&#x27;*.dSYM&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.png&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.eps&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.mod&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.grn&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.shd&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.shd.mat&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	find . -name <span class="string">&#x27;*.prt&#x27;</span>  -<span class="built_in">exec</span> <span class="built_in">rm</span> -r &#123;&#125; +</span><br><span class="line">	(<span class="built_in">cd</span> misc;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> tslib;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Bellhop;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Kraken;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> KrakenField;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Krakel;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> Scooter;	make -k -i clean)</span><br><span class="line">	(<span class="built_in">cd</span> tests;	make -k -i clean)</span><br></pre></td></tr></table></figure>
<h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><p>每次开机时，都需要输入Acoustic Toolbox所在路径，这样电脑每次计算时才会使用里面的程序进行计算</p>
<p>打开终端，输入以下内容，查看bellhop安装路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ~ -name <span class="string">&quot;bellhop.exe&quot;</span></span><br></pre></td></tr></table></figure>
<p>（如果你是windows操作系统，直接将路径加入环境变量<strong>PATH</strong>中（系统属性 -&gt; 环境变量））</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202507031311006.png" alt="image-20250703131147956"></p>
<p>或者直接在终端中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/Users/yourusername/Documents/Bellhop <span class="comment"># 这里设置at中Bellhop文件夹的路径</span></span><br></pre></td></tr></table></figure>
<p>为了每次电脑启动后，不用手动配置，可以将这条命令加入进zsh或者bash配置文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/Users/yourusername/Documents/Bellhop&#x27;</span> &gt;&gt; ~/.zshrc#如果时bash改成.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc#配置生效，如果时bash改成.bashrc</span><br></pre></td></tr></table></figure>
<p>验证路径是否生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> bellhop.exe</span><br></pre></td></tr></table></figure>
<p>如果返回了bellhop.exe的路径，说明配置成功</p>
<h4 id="在jupyter中查看路径是否安装成功"><a href="#在jupyter中查看路径是否安装成功" class="headerlink" title="在jupyter中查看路径是否安装成功"></a>在jupyter中查看路径是否安装成功</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&quot;which bellhop.exe&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果没有返回正确路径，则每次使用前需要手动添加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>] += <span class="string">&quot;:/Users/zanesing/Documents/at/Bellhop&quot;</span>     <span class="comment">#这里填写Bellhop文件夹路径(注意是文件夹路径，不是.exe路径)</span></span><br></pre></td></tr></table></figure>
<h3 id="在python中设置Arlpy"><a href="#在python中设置Arlpy" class="headerlink" title="在python中设置Arlpy"></a>在python中设置Arlpy</h3><p>在命令行输入以下命令，下载arlpy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install arlpy</span><br></pre></td></tr></table></figure>
<p>输入以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> arlpy.uwapm <span class="keyword">as</span> pm</span><br><span class="line">pm.models()</span><br></pre></td></tr></table></figure>
<p>如果返回<strong>[‘Bellhop’]</strong>,说明安装成功</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202507031307424.png" alt="arlpy"></p>
<p>参考文档：</p>
<ul>
<li><p><a href="https://github.com/patel999jay/Bellhop-ARLPY-ECED6575/issues/3#issuecomment-2684876150">https://github.com/patel999jay/Bellhop-ARLPY-ECED6575/issues/3#issuecomment-2684876150</a></p>
</li>
<li><p><a href="https://patel999jay.github.io/post/bellhop-acoustic-toolbox/">https://patel999jay.github.io/post/bellhop-acoustic-toolbox/</a></p>
</li>
<li><a href="http://oalib.hlsresearch.com/AcousticsToolbox/">http://oalib.hlsresearch.com/AcousticsToolbox/</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>论文随笔-CFARnet</title>
    <url>/2025/03/05/CFARnet/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本人最近受够代码了，下定决心来点不一样的，do some math（如果能在下方打赏就更好了，码文不易，希望能赞助     <del>买奶茶钱</del>   买可乐钱）</p>
<p>恒虚警率这个约束是经典符合假设检验中的标准要求，随着科技进步，机器学习这一方法已经开始被人们使用在各个领域 </p>
<p>这篇文章的主要内容：</p>
<ul>
<li><p>定义了一个可以用于贝叶斯和机器学习的CFAR检测器框架：将CFAR约束应用于贝叶斯最优检测器，可以用于任意复合假设检验</p>
</li>
<li><p>提出learning-based CFAR检测器的性能门限，证明CFAR-constrained Bayes检测器渐进收敛于GLRT</p>
</li>
<li><p>提出了CFARnet，一种深度学习的恒虚警检测</p>
</li>
<li><p>将CFARnet与GLRT进行性能对比</p>
<ul>
<li><p>相同性能下：CFARnet计算复杂度&lt;GLRT</p>
</li>
<li><p>GLRT表现不佳时：CFARnet仍有很好的性能，且仍能保持恒虚警特性</p>
</li>
</ul>
</li>
</ul>
<h2 id="检测器"><a href="#检测器" class="headerlink" title="检测器"></a>检测器</h2><h3 id="经典检测器"><a href="#经典检测器" class="headerlink" title="经典检测器"></a>经典检测器</h3><p><strong>似然比检验</strong>（Likelihood Ratio Test,LRT)[1]： </p>
<script type="math/tex; mode=display">
T_{LRT}(\boldsymbol{x}) = 2 \log \frac{p(\boldsymbol{x} \mid z = z_1)}{p(\boldsymbol{x} \mid z = z_0)}</script><p>（此处渲染器出问题了，看图片吧）</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202503051629084.png" alt=""></p>
<p>似然比检验是一种统计检验方法，用于比较两个统计模型的拟合优度。在这个问题中，我们有一个统计量 $ T_{LRT}(\boldsymbol{x}) $</p>
<p>$ p(\boldsymbol{x}; \boldsymbol z = \boldsymbol z_1) $ 是在参数 $ \boldsymbol z = \boldsymbol z_1 $ 下的似然函数值，而 $  p(\boldsymbol{x}; \boldsymbol z = \boldsymbol z_0) $ 是在参数 $ \boldsymbol z = \boldsymbol z_0 $ 下的似然函数值。这个统计量用于检验零假设 $ H_0: \boldsymbol z = \boldsymbol z_0 $ 还是对立假设 $ H_1: \boldsymbol z = \boldsymbol z_1 $</p>
<p>似然比检验统计量 $ T_{LRT}(\boldsymbol{x}) $ 的值越大，表示在 $ \boldsymbol z = \boldsymbol z_1 $ 下的似然函数值比在 $ \boldsymbol z = \boldsymbol z_0 $ 下的似然函数值大得多，因此我们有更强的证据拒绝零假设 $ H_0 $。</p>
<p>在实际应用中，我们通常会将 $T_{LRT}(\boldsymbol{x}) $ 与一个临界值进行比较，如果 $ T_{LRT}(\boldsymbol{x}) $ 大于这个临界值，我们就拒绝零假设 $ H_0 $ ,接收备择假设 $ H_1 $。</p>
<p><strong>广义似然比检验</strong>(Generalized Likelihood Ratio Test,GLRT)[1]：</p>
<script type="math/tex; mode=display">
T_{\mathrm{GLRT}}(\mathbf{x}) = 2\log \frac{\max_{\mathbf{z}\in\mathcal{Z}_1} p(\mathbf{x};\mathbf{z})}{\max_{\mathbf{z}\in\mathcal{Z}_0} p(\mathbf{x};\mathbf{z})}.</script><p>GLRT是最流行的方法，是一种很接近性能门限的方法，但是也存在缺点，因为分子和分母都有max这一处理，设计大规模、非线性以及非凸优化处理，计算复杂度比较高</p>
<blockquote>
<p>GLRT is probably the most popular solution to composite hypothesis testing. It gives a simple recipe that performs well under asymptotic conditions. Its main downsides are that it is sensitive to deviations from its theoretical model, it is generally sub-optimal under finite sample settings, and it may be computationally expensive as both the numerator and denominator of the GLRT involve optimization problems that may be large-scale, non-linear and non-convex. Therefore, there is an ongoing search for flexible, robust, and low-cost alternatives.</p>
</blockquote>
<h3 id="贝叶斯检测器"><a href="#贝叶斯检测器" class="headerlink" title="贝叶斯检测器"></a>贝叶斯检测器</h3><p>贝叶斯检测器（Bayesian LRT）</p>
<p>错误概率：</p>
<script type="math/tex; mode=display">
\text{Pr}_{\text{ERR}} = \text{Pr}(\hat{y} \neq y) = \sum_{y = 0}^{1} \int \mathbf{1}_{\hat{y} \neq y} p(\mathbf{x}, y, \mathbf{z}) d\mathbf{x} d y d\mathbf{z}</script><p>最小化错误概率[2]，就能到得到</p>
<script type="math/tex; mode=display">
T_{\text{BLRT}}(\mathbf{x}) = 2 \log \frac{p_{1}(\mathbf{x})}{p_{0}(\mathbf{x})} = 2 \log \frac{\int_{\mathbf{z} \in \mathcal{Z}_{1}} p(\mathbf{x} ; \mathbf{z}) p(\mathbf{z}) d\mathbf{z}}{\int_{\mathbf{z} \in \mathcal{Z}_{0}} p(\mathbf{x} ; \mathbf{z}) p(\mathbf{z}) d\mathbf{z}}\\
\gamma_{\text{BLRT}} = 2 \log \frac{\text{Pr}(y = 0)}{\text{Pr}(y = 1)}</script><h3 id="本文提出的检测器-CFAR贝叶斯-CLRT"><a href="#本文提出的检测器-CFAR贝叶斯-CLRT" class="headerlink" title="本文提出的检测器-CFAR贝叶斯(CLRT)"></a>本文提出的检测器-CFAR贝叶斯(CLRT)</h3><script type="math/tex; mode=display">
\text{CLRT} : \left\{
\begin{array}{ll}
\min_{T,\gamma} & \Pr_{\text{ERR}}(T, \gamma) \\
\text{s.t.} & T \text{ is CFAR}
\end{array}
\right.</script><script type="math/tex; mode=display">
y=0: z_{r}=z_{r_0},z_n \\
y=1: z_{r}\neq z_{r_0},z_n</script><p>在没有复杂的参数干扰时，BLRT和GLRT是等价的，其中， $ z_r $ ∈ ℝᵈʳ 是一个判别参数， $ z_n $ ∈ ℝᵈⁿ 是一个干扰参数。我们用 $ z_{𝑟_0} $ 和 $ z_{𝑟_1} $ 分别表示在 𝑦 = 0 和 𝑦 = 1 时  $ z_r $ 的真实值。</p>
<h3 id="文章作者的发现："><a href="#文章作者的发现：" class="headerlink" title="文章作者的发现："></a>文章作者的发现：</h3><p>在满足以下条件</p>
<ul>
<li><p>数据由许多来自真实统计模型的独立同分布（i.i.d）样本组成：</p>
<script type="math/tex; mode=display">
p(x;z_r,z _n)=∏_{i=1}^N p(x_i;z_r,z_n),N→∞</script></li>
<li><p>信号是弱的：</p>
<script type="math/tex; mode=display">
∥\bold z_{r_1}− \bold z_{r_0}∥= \frac {s}{\sqrt{N}}</script></li>
<li><p>未知参数的最大似然估计量（ML estimators）是统计有效的，并达到它们的渐近性能</p>
</li>
</ul>
<p>有两个发现：</p>
<script type="math/tex; mode=display">
T_{BLRT}(\bold x)\to T_{GLRT}(\bold x)+func(\bold z_{r_0},\bold z_n)</script><p>GLRT是CLRT的一种变形[3]</p>
<h2 id="基于学习的检测器"><a href="#基于学习的检测器" class="headerlink" title="基于学习的检测器"></a>基于学习的检测器</h2><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503051149496.png" alt="image-20250305114947231"></p>
<p>我们决定将理论用于实际，提出一个机器学习框架，使其性能近似于上述理论</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503051150230.png" alt="image-20250305115004112"></p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503051159963.png" alt="image-20250305115926745"></p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503051159957.png" alt="image-20250305115955792"></p>
<p><strong>参考文献：</strong></p>
<p>[1] S.M. Kay, Fundamentals of statistical signal processing: Detection theory, in: Fundamentals of Statistical SI, Prentice-Hall PTR, 1998.</p>
<p>[2] David de la Mata-Moya, Maria Pilar Jabato-Ananes, Jaime Martin de Nicolas, Manuel Rosa-Zurera, Approximating the Neyman-Pearson detector with 2C-SVMS: application to radar detection, Signal Process. 131 (2017) 364-375.</p>
<p>[3] Pia Addabbo, Dario Benvenuti, Goffredo Poggi, Gastone Ciuti, Danilo Orlando, An application of artificial intelligence to adaptive radar detection using raw data, in: 2023 IEEE Radar Conference, RadarConf23, IEEE, 2023, pp. 1-6.</p>
<p>[4] Tzvi Diskin, Yiftach Beer, Uri Okun, Ami Wiesel,CFARnet: Deep learning for target detection with constant false alarm rate,Signal Processing,Volume223,2024,109543,ISSN 0165-1684</p>
]]></content>
      <categories>
        <category>论文</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文，CFAR</tag>
      </tags>
  </entry>
  <entry>
    <title>DL-CFAR检测算法</title>
    <url>/2025/02/25/DL-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="论文随笔-利用深度学习进行恒虚警检测"><a href="#论文随笔-利用深度学习进行恒虚警检测" class="headerlink" title="论文随笔-利用深度学习进行恒虚警检测"></a>论文随笔-利用深度学习进行恒虚警检测</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前已经提及，常用的CFAR一共有四种方法，但是都有一定的限制，CA-CFAR[1] 利用参考单元功率的算术平均值作为噪声水平估计值。它的一个变种，即单元平均恒定虚警率（GOCA-CFAR）[2]，可以提高原始方案的虚警率。虽然这两种方案在同质场景中表现良好，但在多目标场景中，它们的性能会因错误的噪声水平估计而下降。为了提高多目标场景下的性能，有人提出了最小单元平均 CFAR（SOCA-CFAR）[3]。然而，它在密集多目标场景中并不能显著提高性能。有序统计 CFAR（OS-CFAR）[4] 可以处理这类问题，但它带来了显著的计算复杂性.</p>
<h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1-RDM的获取"><a href="#1-RDM的获取" class="headerlink" title="1.RDM的获取"></a>1.RDM的获取</h3><p>以 FMCW 雷达为例，发射一个由 M 个啁啾（啁啾是频率随时间线性增加的正弦波）组成的帧，然后以逐个啁啾的方式将发射和接收的啁啾混合成 M 个中频（IF）信号。然后，我们在每个啁啾信号中提取 N 个中频信号样本，并使用预定的采样周期。如图所示，CCM 由这些逐个啁啾采样的级联列构成。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf99ac06.png" alt="RDM生成.png"></p>
<p>对信道系数矩阵CCM进行二维FFT，就能获得RDM图。公式如下</p>
<script type="math/tex; mode=display">
\text{RDM}(n,m) = \left| 2\text{D FFT}(\mathbf{H})(n,m) \right|^2 \\= \left| \sum_{k=0}^{N-1} \sum_{l=0}^{M-1} (\mathbf{H})_{k,l} e^{j2\pi lm/M} e^{j2\pi kn/N} \right|^2</script><p>在进行RDM处理后，会获取$10log10(N\times M)$的增益，以便于识别目标 。</p>
<h3 id="2-CFAR"><a href="#2-CFAR" class="headerlink" title="2.CFAR"></a>2.CFAR</h3><p>一种判断是否存在目标，而2D-CFAR不仅能获取方位信息，还能同时获取速度信息</p>
<h2 id="二、DL-CFAR介绍"><a href="#二、DL-CFAR介绍" class="headerlink" title="二、DL-CFAR介绍"></a>二、DL-CFAR介绍</h2><p>设要处理的RDM大小是${N_w}\times{M_w}$,首先将RDM截断(此处可以看作目标+噪声)，然后输入进网络，要注意的是，神经网络并不是进行目标识别，而是估计出所截断的RDM的噪声水平。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9d8d64.png" alt="DL模型.png"></p>
<h2 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h2><h3 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1.数据预处理"></a>1.数据预处理</h3><p>截断处理原因：由于归一化的原因，噪声接近于0</p>
<h3 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h3><p>如图所示，自定义的残差块+自定义的残差块+全连接层+全连接层+激活函数ReLU</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf967233.png" alt="网络结构.png"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLCFAR</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DLCFAR, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.res_block1 = ResidualBlock(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.res_block2 = ResidualBlock(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">16</span> * <span class="number">1</span>, <span class="number">512</span>)  <span class="comment"># Assuming input size is (16, 16, 1)</span></span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.res_block1(x)</span><br><span class="line">        x = F.prelu(x)  <span class="comment"># PReLU activation</span></span><br><span class="line">        x = <span class="variable language_">self</span>.res_block2(x)</span><br><span class="line">        x = F.prelu(x)  <span class="comment"># PReLU activation</span></span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>该网络特点：设计神经网络时不包含任何池化层，因为希望保留 RDM的所有信息，以精确估计噪声水平。</p>
<h3 id="3-训练方式"><a href="#3-训练方式" class="headerlink" title="3.训练方式"></a>3.训练方式</h3><ul>
<li>损失函数：MSE</li>
<li>优化器：Adam</li>
<li>初始学习率：0.00005</li>
<li>batch_size:128</li>
<li>训练次数：500</li>
<li>训练数据集的样本数为 40000 ，验证和测试数据集的样本数均为 200000 </li>
</ul>
<h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4.性能"></a>4.性能</h3><p>在较高信噪比和较低信噪比的时候，性能会有所下降。下图为测试结果偏差和标准差，加粗的是该组中性能能好的。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d1a430.png" alt="性能.png"></p>
<p>代码：（原作者<a href="https://github.com/Vanillaholic/DL_CFAR_data/commits?author=paulchen2713">paulchen2713</a>）</p>
<p>数据生成：<a href="https://github.com/Vanillaholic/DL_CFAR_data">https://github.com/Vanillaholic/DL_CFAR_data</a></p>
<p>目标检测：<a href="https://github.com/Vanillaholic/DL_CFAR">https://github.com/Vanillaholic/DL_CFAR</a>  </p>
<p>参考文献:</p>
<p>[1] C. R. Barrett, Adaptive thresholding and automatic detection.Boston, MA: Springer US, 1987, pp. 368–393. [Online]. Available:<br><a href="https://doi.org/10.1007/978-1-4613-1971-912">https://doi.org/10.1007/978-1-4613-1971-912</a></p>
<p>[2] V. G. Hansen and J. H. Sawyers, “Detectability loss due to ”greatest of”selection in a cell-averaging cfar,” IEEE Trans. Aerosp. Electron. Syst.,vol. AES-16, no. 1, pp. 115–118, Jan. 1980</p>
<p>[3] G. V. Trunk, “Range resolution of targets using automatic detectors,”IEEE Trans. Aeros. Electron. Syst., vol. AES-14, no. 5, pp. 750–755,Sept. 1978.</p>
<p>[4] J. T. Rickard and G. M. Dillard, “Adaptive detection algorithms formultiple-target situations,” IEEE Trans. Aeros. Electron. Syst., vol. AES-13, no. 4, pp. 338–343, July 1977.<br><!--stackedit_data:
eyJoaXN0b3J5IjpbLTU3NTEyMDQ0OF19
--></p>
]]></content>
      <categories>
        <category>信号处理</category>
        <category>CFAR</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>雷达/声纳</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python进行Monte Carlo实验</title>
    <url>/2025/03/03/Monte%20Carlo%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="Monte-Carlo实验"><a href="#Monte-Carlo实验" class="headerlink" title="Monte Carlo实验"></a>Monte Carlo实验</h2><h3 id="方法一：使用multiprocessing包"><a href="#方法一：使用multiprocessing包" class="headerlink" title="方法一：使用multiprocessing包"></a>方法一：使用multiprocessing包</h3><p>使用python进行monte carlo实验，如下图所示，有16个进程可以设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031157277.png" alt="img"></p>
<p>使用模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_trial</span>(<span class="params">trial_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	此处填写实验内容，需要在之前global变量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> success <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    total_epochs = </span><br><span class="line">    <span class="comment">#<span class="doctag">TODO:</span> 导入terminal参数</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some arguments.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--snr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=-<span class="number">5</span>, <span class="built_in">help</span>=<span class="string">&#x27;set the signal-noise ratio&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,<span class="string">&#x27;--output&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;results.txt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;保存结果的文件名&#x27;</span>)</span><br><span class="line">    <span class="comment"># 解析参数</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">with</span> Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 使用 tqdm 显示进度</span></span><br><span class="line">        results = <span class="built_in">list</span>(tqdm(pool.imap(run_trial, <span class="built_in">range</span>(total_epochs)),</span><br><span class="line">                            total=total_epochs, desc=<span class="string">&quot;Running CFAR experiments&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    success_count = <span class="built_in">sum</span>(results)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.output, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">f&quot;虚警概率为: <span class="subst">&#123;P_f&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;SNR: <span class="subst">&#123;args.snr&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;蒙特卡洛实验次数: <span class="subst">&#123;total_epochs&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;检测成功次数: <span class="subst">&#123;success_count&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;检测成功率: <span class="subst">&#123;success_count / total_epochs * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;---------------------------------------------------------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结果已保存到 <span class="subst">&#123;args.output&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用cupy（推荐）"><a href="#方法二：使用cupy（推荐）" class="headerlink" title="方法二：使用cupy（推荐）"></a>方法二：使用cupy（推荐）</h3><p>这个不是默认的，需要额外安装，安装好后按如下步骤调试，即可看运算能力。</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031555578.png" alt="img"></p>
<p>本人使用的是Nvidia-GeForce4060,运算能力是8.9，正好对应</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca8e73319822a38aa6cf5bd07f04863.png" alt=""></p>
<p>此包和numpy是镜像的，所以许多函数是通用的，直接使用即可。cupy在默认情况下，所有的数组操作都是在 GPU 上进行的。CuPy 的设计理念是直接在 GPU 上创建和操作数组，因此不需要显式地将数据从 CPU 转移到 GPU。CuPy 的数组（<code>cupy.ndarray</code>）本身就是存储在 GPU 上的，而 NumPy 的数组（<code>numpy.ndarray</code>）是存储在 CPU 上的。输出：<CUDA Device 0>（表示在 GPU 上）</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031604436.png" alt="image-20250303160400374"></p>
]]></content>
      <categories>
        <category>教学</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>教学</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/05/20/hello-world/</url>
    <content><![CDATA[<h2 id="这是我发的第一篇博客-以此证明我在这个世上存在过……"><a href="#这是我发的第一篇博客-以此证明我在这个世上存在过……" class="headerlink" title="这是我发的第一篇博客,以此证明我在这个世上存在过……"></a>这是我发的第一篇博客,以此证明我在这个世上存在过……</h2><h2 id="如何发表文章"><a href="#如何发表文章" class="headerlink" title="如何发表文章"></a>如何发表文章</h2><h3 id="安装hexo渲染器"><a href="#安装hexo渲染器" class="headerlink" title="安装hexo渲染器"></a>安装hexo渲染器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure>
<p>由于公式原因,需要更换渲染器里的东西,开启KaTeX 需要把 use 设置为 katex<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="comment"># Enable the copy KaTeX formula</span></span><br><span class="line">  <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><br>你不需要添加 katex.min.js 來渲染数学方程。相应的你需要卸載你之前的 hexo 的 markdown 渲染器，然后安装其它插件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 如果有安装这个的话，卸载</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 如果有安装这个的话，卸载</span></span><br><span class="line"></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 需要安装这个渲染插件</span></span><br><span class="line">npm install katex @renbaoshuo/markdown-it-katex <span class="comment">#需要安装这个katex插件</span></span><br></pre></td></tr></table></figure><br>在 hexo 的根目录的 _config.yml 中配置<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;@renbaoshuo/markdown-it-katex&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a><br><!--stackedit_data:
eyJoaXN0b3J5IjpbMTkyNDkxNjgxM119
--></p>
]]></content>
  </entry>
  <entry>
    <title>四种通信序列</title>
    <url>/2025/02/25/%E5%9B%9B%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="一、Costas序列（常用在跳频中）"><a href="#一、Costas序列（常用在跳频中）" class="headerlink" title="一、Costas序列（常用在跳频中）"></a>一、Costas序列（常用在跳频中）</h2><p>在数学中，Costas 数组可以在几何上视为 n 个点的集合，每个点位于 n×n 方块平铺中一个正方形的中心，使得每一行或每一列仅包含一个点，并且每对点之间的 n(n − 1)/2 个位移向量都是不同的。这导致了一个理想的“图钉”自模糊函数，使得这些数组在声纳和雷达等应用中非常有用。可以由对数Welch方法构建。[4]</p>
<p>下图是N=4的costas矩阵</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdf6717b.png" alt="costas序列.png"></p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdfd59df.png" alt="costas信号.png"></p>
<p>这个代码老师没给，仿真时直接上网查输进去的QAQ，但是给了一本书《Radar Signals》(Nadav Leavnopn, Eli Mozaeeson)（这本书年龄比我爷爷都大……），本人用了，一堆报错，真服了……以下是修改改后的代码[10]</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">positions</span> = <span class="title">costas</span><span class="params">(N)</span></span></span><br><span class="line"><span class="comment">% 修复后的函数，修正本原元判断逻辑</span></span><br><span class="line"></span><br><span class="line">positions = [];</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isprime</span>(N+<span class="number">1</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">1</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 1</span></span><br><span class="line">    p = N+<span class="number">1</span>;</span><br><span class="line">    primitive_roots = [];</span><br><span class="line">    <span class="keyword">for</span> e = <span class="number">2</span>:p<span class="number">-1</span></span><br><span class="line">        powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">            primitive_roots = [primitive_roots; e];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(primitive_roots)</span><br><span class="line">        positions = <span class="built_in">zeros</span>(<span class="built_in">length</span>(primitive_roots), p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(primitive_roots)</span><br><span class="line">            e = primitive_roots(<span class="built_in">i</span>);</span><br><span class="line">            positions(<span class="built_in">i</span>, :) = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">isprime</span>(N+<span class="number">2</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">2</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 2</span></span><br><span class="line">    p = N+<span class="number">2</span>;</span><br><span class="line">    primitive_roots = [];</span><br><span class="line">    <span class="keyword">for</span> e = <span class="number">2</span>:p<span class="number">-1</span></span><br><span class="line">        powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">            primitive_roots = [primitive_roots; e];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(primitive_roots)</span><br><span class="line">        positions = <span class="built_in">zeros</span>(<span class="built_in">length</span>(primitive_roots), N);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(primitive_roots)</span><br><span class="line">            e = primitive_roots(<span class="built_in">i</span>);</span><br><span class="line">            freq_sequence = <span class="built_in">mod</span>(e.^(<span class="number">2</span>:p<span class="number">-1</span>), p) - <span class="number">1</span>;</span><br><span class="line">            positions(<span class="built_in">i</span>, :) = freq_sequence;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">isprime</span>(N+<span class="number">3</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">3</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 3 (检查2是否为GF(p)的本原元)</span></span><br><span class="line">    p = N+<span class="number">3</span>;</span><br><span class="line">    e = <span class="number">2</span>;</span><br><span class="line">    powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">    <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">        positions = <span class="built_in">mod</span>(e.^(<span class="number">3</span>:p<span class="number">-1</span>), p) - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数中使用了 Welch 构造方法，这是一种常用的构造 Costas 数组的方法。</li>
<li>函数中还涉及到有限域（GF(p)）的概念，这是数学和密码学中的一个概念，用于确定哪些元素是原始元素。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">positions = costas(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p><strong>典型的应用案例</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>N</th>
<th>构造类型</th>
<th>应用领域</th>
<th>示例序列（部分）</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Welch1</td>
<td>通信跳频</td>
<td><code>[2,4,3,1]</code> 或 <code>[3,4,2,1]</code></td>
<td>[7] [8]</td>
</tr>
<tr>
<td>10</td>
<td>Welch1</td>
<td>雷达抗干扰</td>
<td><code>[2,4,8,5,10,9,7,3,6,1]</code></td>
<td>[8]</td>
</tr>
<tr>
<td>29</td>
<td>未明确</td>
<td>高频声纳</td>
<td><code>[3,21,23,...,25]</code>（29元素序列）</td>
<td>[8]</td>
</tr>
<tr>
<td>15</td>
<td>Welch2</td>
<td>密码学中的密钥序列生成</td>
<td>基于GF(17)生成</td>
<td>[9]</td>
</tr>
</tbody>
</table>
</div>
<p>接下来介绍的都是相位编码</p>
<h2 id="二、m序列"><a href="#二、m序列" class="headerlink" title="二、m序列"></a>二、m序列</h2><ul>
<li>m序列是最大长度序列的简称（Maximum length sequence，MLS） ，就是线性以为寄存器通过线性反馈产生的最长序列，规定级数为r时，产生的码序列为<img src="https://latex.csdn.net/eq?n%3D2%5Er-1" alt="n=2^r-1"></li>
<li>MLS的实际应用包括测量脉冲响应（例如，房间混响或来自海洋拖曳源的到达时间 [1]）,此外还可作为伪随机序列用于直接序列扩频和跳频传输的数字通信系统中。[2]</li>
</ul>
<h3 id="1-m序列的生成"><a href="#1-m序列的生成" class="headerlink" title="1.m序列的生成"></a>1.m序列的生成</h3><p><strong>假设生成多项式是<img src="https://latex.csdn.net/eq?h%28x%29%3D1\*x%5E3+0\*x%5E2+0\*x%5E1+1\*x%5E0" alt="h(x)=1\*x^3+0\*x^2+0\*x^1+1\*x^0">,则移位器如图所示，若移位器系数为1，则之前的线路与异或器相连，如果为0则不相连。</strong></p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdfb507c.png" alt="m序列.png"></p>
<p>MLS 是通过最大线性反馈移位寄存器生成的。下图显示了一个具有长度为 4 的移位寄存器的 MLS 生成系统。它可以用以下递归关系表示：</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdf6deea.png" alt="m序列递归关系.png"></p>
<p>其中 n 是时间索引， + 表示模2 加法。对于比特值 0 = FALSE 或 1 = TRUE，这相当于异或操作。</p>
<p> 此处有介绍的视频：<a href="https://www.bilibili.com/video/BV1BG411k7ws/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a8bad5c878a2bca5d3412ea36a22a7ea">通信原理4.6.1m序列_哔哩哔哩_bilibili</a></p>
<p>代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seq = m_seq(oct)</span></span><br><span class="line"><span class="comment">% Generates an m-sequence using generator given by oct.</span></span><br><span class="line"><span class="comment">% Reference:  Dilip V. Sarwate and Michael B. Pursley, 1980. pp. 599. Fig.1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = <span class="number">5</span> ; l = <span class="number">2</span>^m<span class="number">-1</span> ; <span class="comment">%阶数：5  </span></span><br><span class="line">oct1 = <span class="number">45</span> ;</span><br><span class="line">gen1  = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>] ;<span class="comment">%生成多项式</span></span><br><span class="line">mseq1 = m_seq(oct1,gen1);<span class="comment">%生成m序列</span></span><br></pre></td></tr></table></figure>
<h3 id="2-m序列属性"><a href="#2-m序列属性" class="headerlink" title="2.m序列属性"></a>2.m序列属性</h3><ol>
<li>0和1的数量大致相同</li>
<li>MLS 的线性自相关近似于δ函数[3]</li>
</ol>
<h3 id="3-脉冲响应的提取"><a href="#3-脉冲响应的提取" class="headerlink" title="3. 脉冲响应的提取"></a>3. 脉冲响应的提取</h3><p>如果系统的冲激响应是 h[n]，而 MLS 是 s[n]，那么</p>
<p><img src="https://latex.csdn.net/eq?y%5Bn%5D%3Dh%5Bn%5D*s%5Bn%5D" alt="y[n]=h[n]*s[n]"  /></p>
<p>对两边与s[n]进行相关处理</p>
<p><img src="https://latex.csdn.net/eq?%5Cphi_%7Bsy%7D%3Dh%5Bn%5D*%5Cphi%7Bss%7D" alt="\phi_{sy}=h[n]*\phi{ss}"></p>
<p>由于性质2，当长度足够长时，<img src="https://latex.csdn.net/eq?%5Cphi_%7Bss%7D" alt="\phi_{ss}">近似为一个冲击函数，所以s[n]与y[n]的互相关就是脉冲响应</p>
<p><img src="https://latex.csdn.net/eq?h%5Bn%5D%3D%5Cphi_%7Bsy%7D" alt="h[n]=\phi_{sy}"></p>
<p><a href="https://readit.site/a/XYlZG/Maximum_length_sequence">https://readit.site/a/XYlZG/Maximum_length_sequence</a></p>
<h2 id="三、Gold序列"><a href="#三、Gold序列" class="headerlink" title="三、Gold序列"></a>三、Gold序列</h2><p>Gold序列常用于CDMA[5]和GPS卫星导航[6]</p>
<blockquote>
<p>Gold codes have bounded small <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlations</a> within a set, <strong>which is useful when multiple devices are broadcasting in the same frequency range.</strong></p>
</blockquote>
<p> 引文所说，在一个集合内，互相关性能很小，因此在同意同一频带多用户同通信时很有用</p>
<p>Gold序列的互相关极大值</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7be0b0430.png" alt="gold序列相关.png"></p>
<h3 id="1-Gold序列的生成"><a href="#1-Gold序列的生成" class="headerlink" title="1.Gold序列的生成"></a>1.Gold序列的生成</h3><p> <strong>gold序列是由两个M序列异或得到</strong> </p>
<p> <a href="https://readit.site/a/popNM/Gold_code">https://readit.site/a/popNM/Gold_code</a></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqs</span> = <span class="title">gold</span><span class="params">(oct1,gen)</span></span></span><br><span class="line"><span class="comment">% 此函数用于生成gold序列，输入参数为oct1：和gen：生成多项式系数</span></span><br><span class="line"><span class="comment">% function seqs = gold(oct1)</span></span><br><span class="line"><span class="comment">% This function generates N+2=2^n+1 Gold sequences when (n mod 4 != 0);</span></span><br><span class="line"><span class="comment">% and N+1=2^n Gold-like sequences when (n mod 4 == 0).</span></span><br><span class="line"><span class="comment">% oct1 is the generator polynomial in oct form.</span></span><br><span class="line"><span class="comment">% reference: Dilip V. Sarwate and Michael B. Pursley, 1980.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% some equavalent generators.</span></span><br><span class="line"><span class="comment">% m=3, 13</span></span><br><span class="line"><span class="comment">% m=4, 23</span></span><br><span class="line"><span class="comment">% m=5, 45</span></span><br><span class="line"><span class="comment">% m=6, 103</span></span><br><span class="line"><span class="comment">% m=7, 211</span></span><br><span class="line"></span><br><span class="line">u = m_seq(oct1,gen);</span><br><span class="line">N = <span class="built_in">size</span>(u, <span class="number">2</span>);</span><br><span class="line">n = <span class="built_in">log2</span>(N+<span class="number">1</span>);</span><br><span class="line">t = <span class="number">1</span> + <span class="number">2</span>^(<span class="built_in">floor</span>(n/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">v = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">4</span>) ~=<span class="number">0</span></span><br><span class="line">        seqs = [u; v];</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">                v = rshift(v);</span><br><span class="line">                seqs = [seqs; xor(u, v)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(<span class="number">1</span>, <span class="string">&#x27;Gold sequences\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        seqs = [u];</span><br><span class="line">        v1 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">2</span>);</span><br><span class="line">        v2 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N/<span class="number">3</span></span><br><span class="line">                seqs = [seqs; xor(u, v); xor(u, v1); xor(u, v2)];      </span><br><span class="line">                v = rshift(v); v1 = rshift(v1); v2 = rshift(v2);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(<span class="number">1</span>, <span class="string">&#x27;Gold-like sequences\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seq = m_seq(oct)</span></span><br><span class="line"><span class="comment">% Generates an m-sequence using generator given by oct.</span></span><br><span class="line"><span class="comment">% Reference:  Dilip V. Sarwate and Michael B. Pursley, 1980. pp. 599. Fig.1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">rshift</span><span class="params">(x)</span></span></span><br><span class="line">y = [x(:, <span class="keyword">end</span>), x(:, <span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)];</span><br><span class="line"></span><br><span class="line">m = <span class="number">5</span> ; l = <span class="number">2</span>^m<span class="number">-1</span> ; <span class="comment">%阶数：5  </span></span><br><span class="line">oct1 = <span class="number">45</span> ;</span><br><span class="line">gen  = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>] ;<span class="comment">%生成多项式</span></span><br><span class="line">seqs = gold(oct1,gen);<span class="comment">%生成gold序列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gold1 = seqs(<span class="number">1</span>,:);</span><br><span class="line">gold2 = seqs(<span class="number">15</span>,:);</span><br><span class="line">gold3 = seqs(<span class="number">30</span>,:);</span><br></pre></td></tr></table></figure>
<h2 id="四、Kasami序列"><a href="#四、Kasami序列" class="headerlink" title="四、Kasami序列"></a>四、Kasami序列</h2><p>Kasami 序列是长度为 2 <em>N</em> −1 的二进制序列，其中 N 是偶整数。Kasami 序列具有良好的交叉相关值，接近 Welch 下界。Kasami 序列分为两类——小集和大集。</p>
<h3 id="1kasami序列的生成："><a href="#1kasami序列的生成：" class="headerlink" title="1kasami序列的生成："></a>1kasami序列的生成：</h3><ol>
<li><strong>选择两个不同的M序列</strong>： Kasami序列通常由两个长度相同的M序列（最大长度序列）生成。第一个M序列的生成通常使用一个基准的反馈多项式，而第二个M序列则通过将第一个序列进行适当的位移来获得。</li>
<li><strong>通过异或操作生成Kasami序列</strong>： 通过将这两个M序列进行异或操作得到Kasami序列。对于一个给定的序列，可以通过改变异或操作的位置（即通过移位）来生成多个Kasami序列。</li>
</ol>
<p>eg. 假设我们要生成一个长度为15的Kasami序列，使用两个4阶M序列。</p>
<h4 id="步骤1：生成两个M序列"><a href="#步骤1：生成两个M序列" class="headerlink" title="步骤1：生成两个M序列"></a>步骤1：生成两个M序列</h4><p>假设两个M序列的生成多项式分别为：</p>
<ul>
<li><code>P1 = x^4 + x + 1</code>，对应的反馈结构生成M序列 <code>M1</code>。</li>
<li><code>P2 = x^4 + x^3 + 1</code>，对应的反馈结构生成M序列 <code>M2</code></li>
</ul>
<h4 id="步骤2：生成Kasami序列"><a href="#步骤2：生成Kasami序列" class="headerlink" title="步骤2：生成Kasami序列"></a>步骤2：生成Kasami序列</h4><p>选择一个移位值 <code>d</code>（例如，<code>d = 3</code>），然后将第二个M序列 <code>M2</code> 进行移位并与 <code>M1</code> 异或，生成Kasami序列。 就获得了长度为15的kasami序列</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqs</span> = <span class="title">lkasami</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seqs = lkasami(oct)</span></span><br><span class="line"><span class="comment">% This function generates Large Kasami sequences.</span></span><br><span class="line"><span class="comment">% oct generate an m-sequence of period 2^n-1</span></span><br><span class="line"><span class="comment">% oct should be in oct form. n should be even.</span></span><br><span class="line"><span class="comment">% The first (N+1)^(0.5) sequences are the small set Kasami sequences. </span></span><br><span class="line"><span class="comment">% reference: Dilip V. Sarwate and Michael B. Pursley, 1980.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Qinghua Zhao</span></span><br><span class="line"><span class="comment">% Aug. 2001 at UCSD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%1.先生成m序列</span></span><br><span class="line">seqs = [];</span><br><span class="line">u = m_seq(oct,gen);</span><br><span class="line">N = <span class="built_in">size</span>(u, <span class="number">2</span>); </span><br><span class="line">n = <span class="built_in">log2</span>(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">2</span>) ~= <span class="number">0</span></span><br><span class="line">	fprintf(<span class="number">1</span>, <span class="string">&#x27;No Kasami sequence exist for generator of this order.\n&#x27;</span>);</span><br><span class="line">	beep;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">t = <span class="number">1</span> + <span class="number">2</span>^(n/<span class="number">2</span>+<span class="number">1</span>); <span class="comment">% no need to take floor since it will be an interger.</span></span><br><span class="line">v = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% generate w</span></span><br><span class="line">N_2 = <span class="number">2</span>^(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">w = u(<span class="number">1</span>:N_2:<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">if</span> sum(w)==<span class="number">0</span> <span class="comment">% if all zero sequence, then pick another one. It won&#x27;t be all one sequence since it can only be an m-sequence. </span></span><br><span class="line">	w = u(<span class="number">2</span>:N_2:<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">w = <span class="built_in">ones</span>(N_2, <span class="number">1</span>)*w;</span><br><span class="line">w = <span class="built_in">reshape</span>(w&#x27;, <span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="number">1</span>, <span class="string">&#x27;First %d sequences are small set Kasami\n&#x27;</span>, N_2<span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">4</span>) ~= <span class="number">0</span></span><br><span class="line">	<span class="comment">% generate gold sequences </span></span><br><span class="line">	G_uv = [u; v];</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">	        G_uv = [G_uv; xor(u, v)];</span><br><span class="line">        	v = rshift(v);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% generate kasami sequences</span></span><br><span class="line">	<span class="comment">% the first 2^(n/2) sequences are the small set kasami sequences.</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(G_uv, <span class="number">1</span>)</span><br><span class="line">		seqs = [seqs; G_uv(k,:)];</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N_2<span class="number">-2</span></span><br><span class="line">        		seqs = [seqs; xor(G_uv(k,:), w)];</span><br><span class="line">        		w = rshift(w);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment">% generate gold like sequences</span></span><br><span class="line">	v1 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">2</span>);</span><br><span class="line">	v2 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">3</span>);</span><br><span class="line">	Ht_u = u;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N/<span class="number">3</span></span><br><span class="line"> 		Ht_u = [Ht_u; xor(u, v); xor(u, v1); xor(u, v2)];	</span><br><span class="line">        	v = rshift(v); v1 = rshift(v1); v2 = rshift(v2);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% generate kasami sequences</span></span><br><span class="line">	<span class="comment">% the first 2^(n/2) sequences are the small set kasami sequences.</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(Ht_u, <span class="number">1</span>)</span><br><span class="line">		seqs = [seqs; Ht_u(k,:)];</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N_2<span class="number">-2</span></span><br><span class="line">        		seqs = [seqs; xor(Ht_u(k,:), w)];</span><br><span class="line">        		w = rshift(w);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:(N_2<span class="number">-2</span>)/<span class="number">3</span></span><br><span class="line">		seqs = [seqs; xor(v, w); xor(v1, w); xor(v2, w)];</span><br><span class="line">        	w = rshift(w);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 该函数用于生成m序列，基于给定的生成器oct。</span></span><br><span class="line"><span class="comment">% 参考文献：Dilip V. Sarwate和Michael B. Pursley，1980年。第599页。图1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% gen = oct2gen(oct);     % oct2gen may be removed from future version</span></span><br><span class="line"><span class="comment">%1.查找非零索引，并将序列从该位置之后的位置提取出来</span></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%2.计算生成器的位数和序列的长度</span></span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%3.将生成器反转</span></span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">rshift</span><span class="params">(x)</span></span></span><br><span class="line">y = [x(:, <span class="keyword">end</span>), x(:, <span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)];</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m=<span class="number">4</span>; </span><br><span class="line">oct = <span class="number">23</span>;</span><br><span class="line">gen = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">seqs = lkasami(oct,gen);<span class="comment">%生成gold序列</span></span><br><span class="line">kasami1 = seqs(<span class="number">6</span>,:);</span><br><span class="line">kasami2 = seqs(<span class="number">15</span>,:);</span><br></pre></td></tr></table></figure>
<h2 id="五、其它编码"><a href="#五、其它编码" class="headerlink" title="五、其它编码"></a>五、其它编码</h2><ul>
<li>Phase-Coded Pulse: Barker码</li>
<li><p>Chirplike Phase Codes:</p>
<ul>
<li>Frank Code</li>
<li>P1,P2和Px Codes</li>
<li>Zadoff-Chu Code</li>
<li>Golomb Polyphase Codes</li>
</ul>
</li>
<li><p><strong>Huffman Code</strong></p>
</li>
</ul>
<h2 id="附上常用的本征多项式："><a href="#附上常用的本征多项式：" class="headerlink" title="附上常用的本征多项式："></a>附上常用的本征多项式：</h2><p><img src="https://www.helloimg.com/i/2025/02/26/67be7be1ef382.png" alt="本征多项式.png"></p>
<p><strong>参考文章：</strong></p>
<p>[1] Gemba, Kay L.; Vazquez, Heriberto J.; Fialkowski, Joseph; Edelmann, Geoffrey F.; Dzieciuch, Matthew A.; Hodgkiss, William S. (October 2021). <a href="https://asa.scitation.org/doi/10.1121/10.0006656">“A performance comparison between m-sequences and linear frequency-modulated sweeps for the estimation of travel-time with a moving source”</a>. <em>The Journal of the Acoustical Society of America</em>. <strong>150</strong> (4): 2613–2623. <a href="https://en.wikipedia.org/wiki/Bibcode_(identifier">Bibcode</a>):<a href="https://ui.adsabs.harvard.edu/abs/2021ASAJ..150.2613G">2021ASAJ..150.2613G</a>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier">doi</a>):<a href="https://doi.org/10.1121%2F10.0006656">10.1121/10.0006656</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier">PMID</a>) <a href="https://pubmed.ncbi.nlm.nih.gov/34717519">34717519</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier">S2CID</a>) <a href="https://api.semanticscholar.org/CorpusID:240355915">240355915</a>.</p>
<p>[2] Buracas GT, Boynton GM (July 2002). “Efficient design of event-related fMRI experiments using M-sequences”. <em>NeuroImage</em>. <strong>16</strong> (3 Pt 1): 801–13. <a href="https://en.wikipedia.org/wiki/Doi_(identifier">doi</a>):<a href="https://doi.org/10.1006%2Fnimg.2002.1116">10.1006/nimg.2002.1116</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier">PMID</a>) <a href="https://pubmed.ncbi.nlm.nih.gov/12169264">12169264</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier">S2CID</a>) <a href="https://api.semanticscholar.org/CorpusID:7433120">7433120</a>.</p>
<p>[3] Jacobsen, Finn; Juhl, Peter Moller (2013-06-04). <a href="https://books.google.com/books?id=Sq6uFqlHg1gC">Fundamentals of General Linear Acoustics</a>. John Wiley &amp; Sons. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier">ISBN</a>) <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-1118636176">978-1118636176</a>. A maximum-length sequence is a binary sequence whose circular autocorrelation (except for a small DC-error) is a delta function.</p>
<p>[4] <a href="https://en.wikipedia.org/wiki/Costas_array#CITEREFCostas1965">Costas (1965)</a>; <a href="https://en.wikipedia.org/wiki/Costas_array#CITEREFGilbert1965">Gilbert (1965)</a>; <a href="http://nanoexplanations.wordpress.com/2011/10/09/an-independent-discovery-of-costas-arrays/">An independent discovery of Costas arrays</a>, Aaron Sterling, October 9, 2011. </p>
<p>[5] George, Maria; Hamid, Mujtaba; Miller, Andy (2001-01-10). <a href="https://web.archive.org/web/20080705134550/http://www.xilinx.com/support/documentation/application_notes/xapp217.pdf">“Gold Code Generators in Virtex Devices”</a> (PDF). <em>Virtex Series, Virtex-II Series, and Spartan-II family</em> (Application note). 1.1. <a href="https://en.wikipedia.org/wiki/Xilinx">Xilinx</a>. XAPP217. Archived from <a href="http://www.xilinx.com/support/documentation/application_notes/xapp217.pdf">the original</a> (PDF) on 2008-07-05. (9 pages)</p>
<p>[6] <a href="https://archive.today/20120804185510/http://www.kowoma.de/en/gps/signals.htm">“Transmitted GPS Signals”</a>. <em>The GPS System</em>. kowoma GPS. 2009-04-19. Archived from <a href="http://www.kowoma.de/en/gps/signals.htm">the original</a> on 2012-08-04.</p>
<p>[7] GOLOMB S W, TAYLOR H. Constructions and properties of Costas arrays[J/OL]. Proceedings of the IEEE, 1984: 1143-1163. <a href="https://doi.org/10.1109/proc.1984.12994">https://doi.org/10.1109/proc.1984.12994</a>. DOI:10.1109/proc.1984.12994.</p>
<p>[8] <a href="https://blogs.mathworks.com/steve/2007/02/15/costas-arrays/">https://blogs.mathworks.com/steve/2007/02/15/costas-arrays/</a></p>
<p>[9]KEN TAYLOR,SCOTT RICKARD,KONSTANTINOS DRAKAKIS．Costas Arrays: Survey, Standardization, and MATLAB Toolbox[J]．ACM transactions on mathematical software,2011,37(4):p.38:59-38:89</p>
<p>[10] Levanon, Nadav, E. Mozeson, R. Signals and Chaim Levanon. “RADAR SIGNALS.” (2013).<br><!--stackedit_data:
eyJoaXN0b3J5IjpbLTg0NDk2NjQxXX0=
--></p>
]]></content>
      <categories>
        <category>信号处理</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>雷达/声纳</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Resnet残差网络</title>
    <url>/2025/03/02/resnet/</url>
    <content><![CDATA[<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>模型越复杂,是不是带来的好处就越多呢?<br><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/dI1pRe8l19TP1IXf.png" alt="输入图片说明"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/z1J3qXEVllDkzTIm.png" alt="输入图片说明"></p>
<p>残差块家族也有许多成员<br><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/WqbWs8L80xqNc5pu.png" alt="输入图片说明"></p>
<h3 id="Resnet块"><a href="#Resnet块" class="headerlink" title="Resnet块"></a>Resnet块</h3><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/d47qJCeyNyPB7i85.png" alt="输入图片说明"></p>
<p>重复多次,就得到了resnet网络</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>残差块使得很深的网络更加容易训练<ul>
<li>甚至可以训练一千层的网络</li>
</ul>
</li>
<li>残差网络对随后的深层神经网络设计产生了深远影响，无论是卷积类网络还是全连接类网络</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>图像增广</title>
    <url>/2025/03/04/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%B9%BF/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在不同场景下,图片很可能环境中其他因素干扰,比如噪声</p>
<p>如果在训练数据时引入噪声,模型往往有更好的鲁棒性</p>
<h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><ul>
<li>增加一个已有数据集，使得有更多的多样性<ul>
<li>﻿在语言里面加入各种不同的背景噪音</li>
<li>﻿﻿改变图片的颜色和形状</li>
</ul>
</li>
</ul>
<h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转:"></a>翻转:</h3><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.28.02.png" alt="截屏2025-03-04 15.28.02"></p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.37.01.png" alt="截屏2025-03-04 15.37.01"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">         <span class="comment">#图片,图片增广的办法,生成结果两行四列,scale图片画多大</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">img, aug, num_rows=<span class="number">2</span>, num_cols=<span class="number">4</span>, scale=<span class="number">1.5</span></span>):</span><br><span class="line">    Y = [aug(img) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_rows * num_cols)]</span><br><span class="line">    d2l.show_images(Y, num_rows, num_cols, scale=scale)</span><br><span class="line"></span><br><span class="line">apply(img, torchvision.transforms.RandomVerticalFlip())   <span class="comment">#上下翻转</span></span><br><span class="line">apply(img, torchvision.transforms.RandomHorizontalFlip())  <span class="comment">#左右翻转</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.38.15.png" alt="截屏2025-03-04 15.38.15"></p>
<h3 id="切割"><a href="#切割" class="headerlink" title="切割:"></a>切割:</h3><ul>
<li>﻿从图片中切割一块，然后变形到固定形状<ul>
<li>﻿﻿随机高宽比 （e.g.［3/4,4/3］）</li>
<li>﻿随机大小（e.g.［8%，100%］</li>
<li>﻿随机位</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.30.00.png" alt="截屏2025-03-04 15.30.00"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shape_aug = torchvision.transforms.RandomResizedCrop(</span><br><span class="line">    (<span class="number">200</span>, <span class="number">200</span>), scale=(<span class="number">0.1</span>, <span class="number">1</span>), ratio=(<span class="number">0.5</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#resize到(200,200)  scale:位原始图片的0.1~1倍。ratio:高宽比</span></span><br><span class="line">apply(img, shape_aug)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.42.08.png" alt="截屏2025-03-04 15.42.08"></p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>•改变色调，饱和度，明亮度（e.g.［0.5,1.5］)</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2015.31.58.png" alt="截屏2025-03-04 15.31.58"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apply(img,  <span class="comment">#改变亮度</span></span><br><span class="line">    torchvision.transforms.ColorJitter(brightness=<span class="number">0.5</span>, contrast=<span class="number">0</span>,</span><br><span class="line">                                       saturation=<span class="number">0</span>, hue=<span class="number">0</span>))</span><br><span class="line">apply(img,  <span class="comment">#改变色调</span></span><br><span class="line">    torchvision.transforms.ColorJitter(brightness=<span class="number">0</span>, contrast=<span class="number">0</span>, saturation=<span class="number">0</span>,</span><br><span class="line">                                       hue=<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#随机更改图像的亮度（brightness）、对比度（contrast）、饱和度（saturation）和色调（hue）</span></span><br><span class="line">color_aug = torchvision.transforms.ColorJitter(brightness=<span class="number">0.5</span>, contrast=<span class="number">0.5</span>,</span><br><span class="line">                                               saturation=<span class="number">0.5</span>, hue=<span class="number">0.5</span>)</span><br><span class="line">apply(img, color_aug)</span><br></pre></td></tr></table></figure>
<p>还有许多其他的方法……</p>
<p>只使用最简单的随机左右翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_augs = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.RandomHorizontalFlip(),</span><br><span class="line">    torchvision.transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">test_augs = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor()])</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_computer-vision/image-augmentation.slides.html">https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_computer-vision/image-augmentation.slides.html</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>﻿数据增广通过变形数据来获取多样性从而使得模型泛化性能更好</li>
<li>﻿常见图片增广包括翻转、切割、变色</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>序列模型与循环神经网络</title>
    <url>/2025/03/04/%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>现实生活中,有许多数据并不是像图片一样,看一眼就能了解全部信息.</p>
<p>举个简单的例子:</p>
<p>一句话中,词语的出现顺序可能也会影响这句话的信息量:<strong>“狗咬人”</strong>所带来的信息远没有<strong>“人咬狗”</strong>带来的信息量大……</p>
<p>序列数据已经存在了人们的生活中当中:</p>
<ul>
<li>音乐、语言和视频</li>
<li>地震:大地震后,往往伴随小的余震</li>
</ul>
<h3 id="如何对序列进行统计"><a href="#如何对序列进行统计" class="headerlink" title="如何对序列进行统计"></a>如何对序列进行统计</h3><p>上述提到了信息量,而信息量这个词往往就和概率相关了</p>
<ul>
<li><p>在时间$t$观察到$x_t$，那么得到$T$个不独立的随机变量$(x_1,…x_T) - p(\bold x)$</p>
</li>
<li><p>使用条件概率展开$p(a,b)=p(a)p(b|a)=p(b)p(a|b)$</p>
</li>
</ul>
<p>所以$p(\bold x)$就可以写为条件概率的乘积,如下图所示</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2016.50.52.png" alt="截屏2025-03-04 16.50.52" style="zoom: 50%;" /></p>
<p>$f(\cdot)$表示训练的模型</p>
<h4 id="A-马尔可夫"><a href="#A-马尔可夫" class="headerlink" title="A.马尔可夫"></a>A.马尔可夫</h4><p>当前数据只跟过去有限个数据相关(概率论学过,此处不再赘述)</p>
<h4 id="B-潜变量模型"><a href="#B-潜变量模型" class="headerlink" title="B.潜变量模型"></a>B.潜变量模型</h4><p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2016.54.28.png" alt="截屏2025-03-04 16.54.28" style="zoom: 33%;" /></p>
<h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p>我们决定以潜变量模型为理论基础，搭建一个网络。与多层感知机不同的是，每次隐变量发生更新，每次的输出取决于当下输出和前一时间的隐变量</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503051518698.png" style="zoom:50%;" /></p>
<p>这张图很好的展示了循环神经网络的工作原理，第4层就是循环神经网络层</p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/IMG_0722.GIF" alt="IMG_0722"></p>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/IMG_0719.jpg" alt="IMG_0719" style="zoom:33%;" /></p>
<p>如图所示,第四层网络的输入不仅有上一网络的输出,还有上一次计算时自己本身的输出</p>
<h3 id="困惑度（perplexity）"><a href="#困惑度（perplexity）" class="headerlink" title="困惑度（perplexity）"></a>困惑度（perplexity）</h3><p>衡量一个语言模型的好坏可以用平均交叉熵</p>
<script type="math/tex; mode=display">
\pi=\frac{1}{n}\sum_{i=1}^n-\log p(x_t|x_{t-1},...)</script><p>p是模型的预测概率，xt是真实值，困惑度就是$ exp(\pi) $</p>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>一种防止梯度爆炸的方式，假设所有层的梯度为g，如果g的长度超过θ，那么长度将会被拉回θ</p>
<script type="math/tex; mode=display">
\mathbf{g}\leftarrow\min\left(1,\frac{\theta}{\|\mathbf{g}\|}\right)\mathbf{g}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里的代码比较复杂,所以没有全部放入文章中建议认真看</p>
<p><a href="https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_recurrent-neural-networks/sequence.slides.html#/">https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_recurrent-neural-networks/sequence.slides.html#/</a></p>
<p>使用正弦函数和一些可加性噪声来生成序列数据，时间步为 1,2,…,1000</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">T = <span class="number">1000</span></span><br><span class="line">time = torch.arange(<span class="number">1</span>, T + <span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">x = torch.sin(<span class="number">0.01</span> * time) + torch.normal(<span class="number">0</span>, <span class="number">0.2</span>, (T,))</span><br><span class="line">d2l.plot(time, [x], <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, xlim=[<span class="number">1</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>将数据映射为数据对 yt=xtyt=xt 和 xt=[xt−τ,…,xt−1]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tau = <span class="number">4</span></span><br><span class="line">features = torch.zeros((T - tau, tau))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    features[:, i] = x[i:T - tau + i]</span><br><span class="line">labels = x[tau:].reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">batch_size, n_train = <span class="number">16</span>, <span class="number">600</span></span><br><span class="line">train_iter = d2l.load_array((features[:n_train], labels[:n_train]),</span><br><span class="line">                            batch_size, is_train=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>使用一个相当简单的结构：只是一个拥有两个全连接层的多层感知机</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(nn.Linear(<span class="number">4</span>, <span class="number">10</span>), nn.ReLU(), nn.Linear(<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">loss = nn.MSELoss()</span><br></pre></td></tr></table></figure>
<p>训练模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, loss, epochs, lr</span>):</span><br><span class="line">    trainer = torch.optim.Adam(net.parameters(), lr)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            trainer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            trainer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;loss: <span class="subst">&#123;d2l.evaluate_loss(net, train_iter, loss):f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">net = get_net()</span><br><span class="line">train(net, train_iter, loss, <span class="number">5</span>, <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>
<p>模型预测下一个时间步</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">onestep_preds = net(features)</span><br><span class="line">d2l.plot(</span><br><span class="line">    [time, time[tau:]],</span><br><span class="line">    [x.detach().numpy(), onestep_preds.detach().numpy()], <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">    legend=[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;1-step preds&#x27;</span>], xlim=[<span class="number">1</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202503051556783.png" alt="image-20250305155649696"></p>
<p>进行多步预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multistep_preds = torch.zeros(T)</span><br><span class="line">multistep_preds[:n_train + tau] = x[:n_train + tau]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_train + tau, T):</span><br><span class="line">    multistep_preds[i] = net(multistep_preds[i - tau:i].reshape((<span class="number">1</span>, -<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">d2l.plot([time, time[tau:], time[n_train + tau:]], [</span><br><span class="line">    x.detach().numpy(),</span><br><span class="line">    onestep_preds.detach().numpy(),</span><br><span class="line">    multistep_preds[n_train + tau:].detach().numpy()], <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">         legend=[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;1-step preds&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;multistep preds&#x27;</span>], xlim=[<span class="number">1</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>更仔细地看一下k步预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_steps = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">features = torch.zeros((T - tau - max_steps + <span class="number">1</span>, tau + max_steps))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau):</span><br><span class="line">    features[:, i] = x[i:i + T - tau - max_steps + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tau, tau + max_steps):</span><br><span class="line">    features[:, i] = net(features[:, i - tau:i]).reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">steps = (<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">d2l.plot([time[tau + i - <span class="number">1</span>:T - max_steps + i] <span class="keyword">for</span> i <span class="keyword">in</span> steps],</span><br><span class="line">         [features[:, (tau + i - <span class="number">1</span>)].detach().numpy() <span class="keyword">for</span> i <span class="keyword">in</span> steps], <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;x&#x27;</span>, legend=[<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span>-step preds&#x27;</span></span><br><span class="line">                      <span class="keyword">for</span> i <span class="keyword">in</span> steps], xlim=[<span class="number">5</span>, <span class="number">1000</span>], figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202503051558239.png" alt="image-20250305155817153"></p>
<p><a href="https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_recurrent-neural-networks/rnn-concise.slides.html#/">https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_recurrent-neural-networks/rnn-concise.slides.html#/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure>
<p>定义模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_hiddens = <span class="number">256</span></span><br><span class="line">rnn_layer = nn.RNN(<span class="built_in">len</span>(vocab), num_hiddens)</span><br></pre></td></tr></table></figure>
<p>使用张量来初始化隐藏状态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state = torch.zeros((<span class="number">1</span>, batch_size, num_hiddens))</span><br><span class="line">state.shape</span><br></pre></td></tr></table></figure>
<p>通过一个隐藏状态和一个输入，我们可以用更新后的隐藏状态计算输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(size=(num_steps, batch_size, <span class="built_in">len</span>(vocab)))</span><br><span class="line">Y, state_new = rnn_layer(X, state)</span><br><span class="line">Y.shape, state_new.shape</span><br></pre></td></tr></table></figure>
<p>我们为一个完整的循环神经网络模型定义一个<code>RNNModel</code>类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RNNModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环神经网络模型。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rnn_layer, vocab_size, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(RNNModel, <span class="variable language_">self</span>).__init__(**kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.rnn = rnn_layer</span><br><span class="line">        <span class="variable language_">self</span>.vocab_size = vocab_size</span><br><span class="line">        <span class="variable language_">self</span>.num_hiddens = <span class="variable language_">self</span>.rnn.hidden_size</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.rnn.bidirectional:</span><br><span class="line">            <span class="variable language_">self</span>.num_directions = <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.linear = nn.Linear(<span class="variable language_">self</span>.num_hiddens, <span class="variable language_">self</span>.vocab_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.num_directions = <span class="number">2</span></span><br><span class="line">            <span class="variable language_">self</span>.linear = nn.Linear(<span class="variable language_">self</span>.num_hiddens * <span class="number">2</span>, <span class="variable language_">self</span>.vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, state</span>):</span><br><span class="line">        X = F.one_hot(inputs.T.long(), <span class="variable language_">self</span>.vocab_size)</span><br><span class="line">        X = X.to(torch.float32)</span><br><span class="line">        Y, state = <span class="variable language_">self</span>.rnn(X, state)</span><br><span class="line">        output = <span class="variable language_">self</span>.linear(Y.reshape((-<span class="number">1</span>, Y.shape[-<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, device, batch_size=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="variable language_">self</span>.rnn, nn.LSTM):</span><br><span class="line">            <span class="keyword">return</span> torch.zeros((<span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                                batch_size, <span class="variable language_">self</span>.num_hiddens), device=device)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (torch.zeros((<span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                                 batch_size, <span class="variable language_">self</span>.num_hiddens),</span><br><span class="line">                                device=device),</span><br><span class="line">                    torch.zeros((<span class="variable language_">self</span>.num_directions * <span class="variable language_">self</span>.rnn.num_layers,</span><br><span class="line">                                 batch_size, <span class="variable language_">self</span>.num_hiddens),</span><br><span class="line">                                device=device))</span><br></pre></td></tr></table></figure>
<p>用一个具有随机权重的模型进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = d2l.try_gpu()</span><br><span class="line">net = RNNModel(rnn_layer, vocab_size=<span class="built_in">len</span>(vocab))</span><br><span class="line">net = net.to(device)</span><br><span class="line">d2l.predict_ch8(<span class="string">&#x27;time traveller&#x27;</span>, <span class="number">10</span>, net, vocab, device)</span><br></pre></td></tr></table></figure>
<p>使用高级API训练模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">d2l.train_ch8(net, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/202503051551451.png" alt="image-20250305155136369" style="zoom: 67%;" /></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>循环神经网络的输出取决于当下输入和前一时间的隐变量</li>
<li>应用到语言模型中时，循环神经双络根据一前词预测下一次时刻词</li>
<li>通常使用困惑度来衡量语言模型的好坏</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>微调</title>
    <url>/2025/03/04/%E5%BE%AE%E8%B0%83/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>神经网络除了最后一部分,其余部分都是在做特征提取,如果目标数据集属于原数据集,那么训练好的模型就可以直接拿来用了.</p>
<p>实际上Chatgpt就是属于这种(一句话总结:让你的模型站在巨人的肩膀上……) </p>
<p>假设使用数据集已经训练出了一个模型,那这个对目标数据集仍有很好的适用性(最后一层因为label的原因,往往发生改变)</p>
<p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E5%9B%BE%E7%89%87%201.png" alt="图片 1"></p>
<h2 id="微调的方式"><a href="#微调的方式" class="headerlink" title="微调的方式"></a>微调的方式</h2><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><ul>
<li>是一个目标数据集上的正常训练任务，但使用更强的正则化<ul>
<li>﻿﻿使用更小的学习率</li>
<li>﻿﻿使用更少的数据迭代</li>
</ul>
</li>
<li>﻿﻿源数据集远复杂于目标数据，通常微调效果更好</li>
</ul>
<h3 id="重用分类器权重"><a href="#重用分类器权重" class="headerlink" title="重用分类器权重"></a>重用分类器权重</h3><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/截屏2025-03-04 16.10.07.png" alt=""></p>
<h3 id="固定一些层"><a href="#固定一些层" class="headerlink" title="固定一些层"></a>固定一些层</h3><ul>
<li>﻿神经网络通常学习有层次的特征表示<ul>
<li>﻿﻿低层次的特征更加通用</li>
<li>﻿﻿高层次的特征则更跟数据集相关</li>
</ul>
</li>
<li>﻿可以固定底部一些层的参数，不参与<br> 更新<ul>
<li>﻿﻿更强的正则</li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里的代码比较复杂,所以没有全部放入文章中建议认真看</p>
<p><a href="https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_computer-vision/fine-tuning.slides.html">https://courses.d2l.ai/zh-v2/assets/notebooks/chapter_computer-vision/fine-tuning.slides.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_net = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pretrained_net.fc</span><br></pre></td></tr></table></figure>
<p>Linear(in_features=512, out_features=1000, bias=True)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">finetune_net = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">finetune_net.fc = nn.Linear(finetune_net.fc.in_features, <span class="number">2</span>)  <span class="comment">#输出种类变化,改成2</span></span><br><span class="line">nn.init.xavier_uniform_(finetune_net.fc.weight);</span><br></pre></td></tr></table></figure>
<p>微调模型:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_fine_tuning</span>(<span class="params">net, learning_rate, batch_size=<span class="number">128</span>, num_epochs=<span class="number">5</span>,</span></span><br><span class="line"><span class="params">                      param_group=<span class="literal">True</span></span>):</span><br><span class="line">    train_iter = torch.utils.data.DataLoader(</span><br><span class="line">        torchvision.datasets.ImageFolder(os.path.join(data_dir, <span class="string">&#x27;train&#x27;</span>),</span><br><span class="line">                                         transform=train_augs),</span><br><span class="line">        batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    test_iter = torch.utils.data.DataLoader(</span><br><span class="line">        torchvision.datasets.ImageFolder(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>),</span><br><span class="line">                                         transform=test_augs),</span><br><span class="line">        batch_size=batch_size)</span><br><span class="line">    devices = d2l.try_all_gpus()</span><br><span class="line">    loss = nn.CrossEntropyLoss(reduction=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> param_group:  <span class="comment">#此处发生变化:如果这个参数存在</span></span><br><span class="line">        params_1x = [</span><br><span class="line">            param <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;fc.weight&quot;</span>, <span class="string">&quot;fc.bias&quot;</span>]]</span><br><span class="line">        trainer = torch.optim.SGD([&#123;  <span class="comment">#只有最后一层学习率发生变化</span></span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: params_1x&#125;, &#123;</span><br><span class="line">                <span class="string">&#x27;params&#x27;</span>: net.fc.parameters(),</span><br><span class="line">                <span class="string">&#x27;lr&#x27;</span>: learning_rate * <span class="number">10</span>&#125;], lr=learning_rate,</span><br><span class="line">                                  weight_decay=<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment">#如果没有True,则跟之前一样</span></span><br><span class="line">        trainer = torch.optim.SGD(net.parameters(), lr=learning_rate,</span><br><span class="line">                                  weight_decay=<span class="number">0.001</span>)</span><br><span class="line"> 		d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs,</span><br><span class="line">                   devices)</span><br></pre></td></tr></table></figure>
<h3 id="是否使用预训练的比较"><a href="#是否使用预训练的比较" class="headerlink" title="是否使用预训练的比较"></a>是否使用预训练的比较</h3><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/%E6%88%AA%E5%B1%8F2025-03-04%2016.27.13.png" alt="截屏2025-03-04 16.27.13"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>﻿微调通过使用在大数据上得到的预训练好的模型来初始化模型权重来完成提升精度</li>
<li>﻿﻿预训练模型质量很重要</li>
<li>﻿﻿微调通常速度更快、精度更</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>恒虚警检测器CFAR</title>
    <url>/2025/02/24/%E6%81%92%E8%99%9A%E8%AD%A6%E6%A3%80%E6%B5%8B%E5%99%A8CFAR/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>雷达的检测过程可用门限检测来描述。几乎所有的判断都是以接收机的输出与某个门限电平的比较为基础的，如果接收机输出的包络超过了某一设置门限，就认为出现了目标。<br>雷达在探测时会受到噪声、杂波和干扰的影响，因而采用固定门限进行目标检测时会产生一定的虚警，特别是当杂波背景起伏变化时虚警率会急剧上升，严重影响雷达的检测性能。因此，根据雷达杂波数据动态调整检测门限，在虚警概率保持不变的情况下实现目标检测概率最大化，这种方法称为<strong>恒虚警率（Constant False Alarm Rate，CFAR）检测技术</strong>。</p>
<ul>
<li>虚警：在没有目标时判断为有目标（没有-&gt;有）</li>
<li>漏警：在有目标时判断为没有目标（有-&gt;没有）</li>
</ul>
<h2 id="二、CFAR检测算法"><a href="#二、CFAR检测算法" class="headerlink" title="二、CFAR检测算法"></a>二、CFAR检测算法</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><p>在实际工作过程中，将信号与阈值进行比较来判断信号的有无，这个阈值的计算就用到了检测概率和虚警概率、漏警概率。对于声纳系统的来说，<strong>阈值的选择目的在于保证最大化的检测概率以及虚警概率小于一定的量级。</strong></p>
<p>在CFAR中，检测需要一个指定的距离单元，常被成为被，称为检测单元(CUT, cell under test)，噪声功率根据临近的距离单元得到。检测的阈值为T，有如下表达式：</p>
<script type="math/tex; mode=display">
T=aP_n</script><p>P_n表示噪声功率估计，a是缩放因子，选取一个合适的因子，虚警概率就可以保持为一个常数，因此该方法称为CFAR。</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d1657b.png" alt="CFAR-TH.png"></p>
<p>阈值随着信号的噪声功率增加，以保持恒定的虚警率。当信号水平超过阈值时，会发生检测。</p>
<h3 id="2-典型的CFAR算法"><a href="#2-典型的CFAR算法" class="headerlink" title="2.典型的CFAR算法"></a>2.典型的CFAR算法</h3><h5 id="2-1-均值类CFAR-CA-CFAR-算法"><a href="#2-1-均值类CFAR-CA-CFAR-算法" class="headerlink" title="2.1 均值类CFAＲ(CA-CFAＲ)算法"></a>2.1 均值类CFAＲ(CA-CFAＲ)算法</h5><p>一维情况如下所示：</p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0c72f26.png" alt="CFAR.png"></p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9bdf49.png" alt="1d-cafr.png"></p>
<p>最中间的检测单元，其次是守护单元(保护单元主要用在单目标情况下，防止目标能量泄漏到参考单元影响检测效果)，最外围是训练单元，噪声估计可以计算为：</p>
<script type="math/tex; mode=display">
P_n = \frac{1}{2N} \sum_{m=1}^{2N} x_m</script><p>其中，训练单元的长度为2N，x是训练单元中的样本[1]</p>
<blockquote>
<p>With the above cell averaging CFAR detector, assuming the data passed into the detector is from a single pulse, i.e., no pulse integration involved, the threshold factor can be written as [1]<br>使用上述单元平均 CFAR 检测器，假设传入检测器的数据来自单个脉冲，即不涉及脉冲积分，阈值因子可以写为 [1]</p>
</blockquote>
<script type="math/tex; mode=display">
\alpha = 2N( P_{fa}^{-1/2N} - 1)</script><p>推导见[4]</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 距离测量 (Range Measurement)</span></span><br><span class="line"><span class="comment">% 将混频信号（Mix）重塑为 Nr x Nd 的矩阵</span></span><br><span class="line"><span class="comment">% Nr：距离维度（每个 Chirp 的采样点数）</span></span><br><span class="line"><span class="comment">% Nd：多普勒维度（Chirp 数量）</span></span><br><span class="line">sig = <span class="built_in">reshape</span>(Mix, [Nr, Nd]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在距离维度 (Nr) 上对打拍频信号进行 FFT 变换</span></span><br><span class="line">sig_fft1 = fft(sig, Nr); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 对 FFT 结果进行归一化处理</span></span><br><span class="line">sig_fft1 = sig_fft1 ./ Nr;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取 FFT 结果的幅值（只关注频谱强度）</span></span><br><span class="line">sig_fft1 = <span class="built_in">abs</span>(sig_fft1);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT 结果是双边谱，只保留单边谱（正频率部分）</span></span><br><span class="line">sig_fft1 = sig_fft1(<span class="number">1</span>:(Nr/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制距离维度的 FFT 结果</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Range from First FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制 1D FFT 输出，展示距离信息</span></span><br><span class="line"><span class="built_in">plot</span>(sig_fft1, <span class="string">&quot;LineWidth&quot;</span>,<span class="number">2</span>);</span><br><span class="line">grid on;axis ([<span class="number">0</span> <span class="number">200</span> <span class="number">0</span> <span class="number">0.5</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;range&#x27;</span>);ylabel(<span class="string">&#x27;FFT output&#x27;</span>);title(<span class="string">&#x27;1D FFT&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="2-2-最大选择GO-Greatest-Of-CFAR-amp-最小选择SO-Smallest-Of-CFAR"><a href="#2-2-最大选择GO-Greatest-Of-CFAR-amp-最小选择SO-Smallest-Of-CFAR" class="headerlink" title="2.2 最大选择GO(Greatest Of)-CFAR &amp;最小选择SO(Smallest Of)-CFAR"></a>2.2 最大选择GO(Greatest Of)-CFAR &amp;最小选择SO(Smallest Of)-CFAR</h5><p>最大选择就是选取前后n个训练单元之和进行对比，选取最大值作为噪声功率水平</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{l}
Y_1 = \sum_{i=1}^{n} X_i \\
Y_2 = \sum_{i=n+1}^{2n} X_i \\
GO: \max(Y_1, Y_2)
\end{array}
\right.</script><p>最小选择就是选取最小选择</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{l}
Y_1 = \sum_{i=1}^{n} X_i \\
Y_2 = \sum_{i=n+1}^{2n} X_i \\
SO: \min(Y_1, Y_2)
\end{array}
\right.</script><h5 id="2-3-有序统计类CFAR-OS-CFAR-算法"><a href="#2-3-有序统计类CFAR-OS-CFAR-算法" class="headerlink" title="2.3 有序统计类CFAＲ(OS-CFAＲ)算法"></a>2.3 有序统计类CFAＲ(OS-CFAＲ)算法</h5><p>OS(Order Statistic)CFAR的原理是先对参考单元从小到大排序</p>
<script type="math/tex; mode=display">
 P_{fa, os} = k \binom{R}{k} \frac{\Gamma(R-k+1+T) \Gamma(k)}{\Gamma(R+1+T)}</script><p><em>R</em>=2<em>n</em>，k  为OS-CFAR中的参数，其值的选取对算法的检测性能有较大影响[3]。</p>
<h3 id="三、性能比较"><a href="#三、性能比较" class="headerlink" title="三、性能比较"></a>三、性能比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>CFAR 类型</th>
<th>参考电平 Z</th>
<th>适用场合</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>CA-CFAR</td>
<td>(X+Y)/2</td>
<td>均匀杂波背景</td>
<td>在杂波边缘会引起虚警率的上升；多目标环境中的检测性能较差。</td>
</tr>
<tr>
<td>SO-CFAR</td>
<td>min{X, Y}</td>
<td>在干扰目标位于前沿或后沿滑窗之一的多目标环境中能分辨出主目标。</td>
<td>杂波边缘和均匀杂波环境中的检测性能较差。</td>
</tr>
<tr>
<td>GO-CFAR</td>
<td>max{X, Y}</td>
<td>在杂波边缘和均匀杂波环境能保持较好的检测性能。</td>
<td>多目标环境中的检测性能较差。</td>
</tr>
<tr>
<td>OS-CFAR</td>
<td>(ascend_sort{X, Y})</td>
<td>多目标检测性能较好。</td>
<td>依赖于参考窗内的所有样本数据，且 k 的取值直接决定了检测结果的优劣。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d00b60.jpg" alt="CFAR_performance.jpg"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% ------ 程序功能：四类CFAR检测算法的检测概率与SNR的关系 %</span></span><br><span class="line">clc</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">R = <span class="number">24</span>;                     <span class="comment">% 参考单元长度</span></span><br><span class="line">n = R/<span class="number">2</span>;                    <span class="comment">% 半滑窗长度</span></span><br><span class="line">k = R*<span class="number">3</span>/<span class="number">4</span>;                  <span class="comment">% os-cfar的参数</span></span><br><span class="line">P_fa = <span class="number">1e-6</span>;                <span class="comment">% 虚警概率</span></span><br><span class="line">SNR_dB = (<span class="number">0</span>:<span class="number">30</span>);            <span class="comment">% 信噪比</span></span><br><span class="line">SNR = <span class="number">10.</span>^(SNR_dB./<span class="number">10</span>);     <span class="comment">% 信号功率与噪声功率的比值</span></span><br><span class="line">syms T;                     <span class="comment">% 门限因子的符号变量</span></span><br><span class="line"><span class="comment">%% CA-CFAR</span></span><br><span class="line">T_CA = P_fa^(<span class="number">-1</span>/R)<span class="number">-1</span>;           <span class="comment">% CA-CFAR的门限因子</span></span><br><span class="line">Pd_CA = (<span class="number">1</span>+T_CA./(<span class="number">1</span>+SNR)).^(-R);    <span class="comment">% CA-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% SO-CFAR、GO-CFAR</span></span><br><span class="line">Pfa_SO = <span class="number">0</span>;</span><br><span class="line">syms T</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span>:n<span class="number">-1</span></span><br><span class="line">    Pfa_SO = Pfa_SO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">i</span>)*(<span class="number">2</span>+T)^(-(n+<span class="built_in">i</span>));     <span class="comment">% SO-CFAR的虚警概率表达式</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T1_SO = solve(Pfa_SO == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_SO = double(T1_SO);</span><br><span class="line">T_SO = T2_SO(T2_SO == <span class="built_in">abs</span>(T2_SO));      <span class="comment">% SO-CFAR的门限因子</span></span><br><span class="line"></span><br><span class="line">Pfa_GO = <span class="number">2</span>*(<span class="number">1</span>+T)^(-n)-Pfa_SO;           <span class="comment">% GO-CFAR的虚警概率表达式</span></span><br><span class="line">T1_GO = solve(Pfa_GO == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_GO = double(T1_GO);</span><br><span class="line">T_GO = T2_GO(T2_GO == <span class="built_in">abs</span>(T2_GO));      <span class="comment">% GO-CFAR的门限因子</span></span><br><span class="line"></span><br><span class="line">Pd_SO = <span class="number">0</span>;</span><br><span class="line">Pd_GO = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">0</span>:n<span class="number">-1</span></span><br><span class="line">    Pd_SO = Pd_SO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>).*(<span class="number">2</span>+T_SO./(<span class="number">1</span>+SNR)).^(-(n+<span class="built_in">j</span>));     <span class="comment">% SO-CFAR的检测概率</span></span><br><span class="line">    Pd_GO = Pd_GO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>).*(<span class="number">2</span>+T_GO./(<span class="number">1</span>+SNR)).^(-(n+<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Pd_GO = <span class="number">2.</span>*(<span class="number">1</span>+T_GO./(<span class="number">1</span>+SNR)).^(-n)-Pd_GO;         <span class="comment">% GO-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% OS-CFAR</span></span><br><span class="line">Pfa_OS = k*<span class="built_in">nchoosek</span>(R,k)*<span class="built_in">gamma</span>(R-k+<span class="number">1</span>+T)*<span class="built_in">gamma</span>(k)/<span class="built_in">gamma</span>(R+T+<span class="number">1</span>);           <span class="comment">% OS-CFAR的虚警概率表达式</span></span><br><span class="line">T1_OS = solve(Pfa_OS == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_OS = double(T1_OS);</span><br><span class="line">T_OS = T2_OS(T2_OS == <span class="built_in">abs</span>(T2_OS));      <span class="comment">% OS-CFAR的门限因子</span></span><br><span class="line">Pd_OS = k*<span class="built_in">nchoosek</span>(R,k)*<span class="built_in">gamma</span>(R-k+<span class="number">1</span>+T_OS./(<span class="number">1</span>+SNR))*<span class="built_in">gamma</span>(k)./<span class="built_in">gamma</span>(R+T_OS./(<span class="number">1</span>+SNR)+<span class="number">1</span>);      <span class="comment">% OS-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_CA,<span class="string">&#x27;r-*&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_SO,<span class="string">&#x27;k-^&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_GO,<span class="string">&#x27;b-o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_OS,<span class="string">&#x27;m-.&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;SNR&#x27;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;Time New Romans&#x27;</span>,<span class="string">&#x27;FontAngle&#x27;</span>,<span class="string">&#x27;italic&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;P_&#123;d&#125;&#x27;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;Time New Romans&#x27;</span>,<span class="string">&#x27;FontAngle&#x27;</span>,<span class="string">&#x27;italic&#x27;</span>);</span><br><span class="line">title([<span class="string">&#x27;恒虚警率 P_&#123;fa&#125;= &#x27;</span>,num2str(P_fa),<span class="string">&#x27;，参考单元 2n= &#x27;</span>,num2str(R)]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;SO&#x27;</span>,<span class="string">&#x27;GO&#x27;</span>,<span class="string">&#x27;OS&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Mark Richards, <em>Fundamentals of Radar Signal Processing</em>, McGraw Hill, 2005</p>
<p>[2] 王蓓. 基于杂波图的恒虚警处理技术研究[D]. 西安电子科技大学, 2018.</p>
<p>[3] Detection loss due to interfering targets in ordered statistics CFAR.</p>
<p>[4] P. P. Gandhi and S. A. Kassam, “Analysis of CFAR processors in nonhomogeneous background,” in IEEE Transactions on Aerospace and Electronic Systems, vol. 24, no. 4, pp. 427-445, July 1988, doi: 10.1109/7.7185.<br>keywords: {Detectors;Radar detection;Degradation;Radar clutter;Senior members;Statistical distributions;Process design;Performance analysis;Clouds;Noise level},<br><!--stackedit_data:
eyJoaXN0b3J5IjpbNTQwMTE0MjUwXX0=
--></p>
]]></content>
      <categories>
        <category>信号处理</category>
        <category>CFAR</category>
      </categories>
      <tags>
        <tag>雷达/声纳</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>batch norm批量归一化</title>
    <url>/2025/03/02/%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在训练模型的时候,对于一个网络来说:</p>
<ul>
<li>前部:数据集中在前部,网络前面的层变化,则会导致后面的层也跟着变化-&gt;收敛速度慢</li>
<li>后部:损失是集中在网络后面的,所以往往后面的层训练较快<br>那有没有一种方式,使网络后面的层尽量保持不变呢?<h2 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>通过固定小批量数据的均值和方差，再引入可学习参数 γ 和 β 对数据进行调整，有助于加速模型的训练收敛，提高模型的稳定性 。<br>计算小批量均值和方差的公式：<script type="math/tex; mode=display">
\mu_B = \frac{1}{|B|} \sum_{i\in B} x_i \text{ and } \sigma_B^2 = \frac{1}{|B|} \sum_{i\in B} (x_i - \mu_B)^2 + \epsilon</script>然后对其做额外的调整:<script type="math/tex; mode=display">
x_{i + 1} = \gamma \frac{x_i - \mu_B}{\sigma_B} + \beta</script>不再学习均值和方差,转而学习参数 γ 和 β <h3 id="作用位置"><a href="#作用位置" class="headerlink" title="作用位置"></a>作用位置</h3></li>
<li>作用在<ul>
<li>全连接层和卷积层输出上，激活函数前</li>
<li>全连接层和卷积层输入上</li>
</ul>
</li>
<li>对全连接层，作用在特征维</li>
<li>对于卷积层，作用在通道维</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">6</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">                    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">256</span>, <span class="number">120</span>), nn.BatchNorm1d(<span class="number">120</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.BatchNorm1d(<span class="number">84</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>拉伸参数 <code>gamma</code> 和偏移参数 <code>beta</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net[<span class="number">1</span>].gamma.reshape((-<span class="number">1</span>,)), net[<span class="number">1</span>].beta.reshape((-<span class="number">1</span>,))</span><br></pre></td></tr></table></figure><br>(tensor([2.1534, 2.1612, 2.0096, 1.9473, 1.8451, 1.3328], device=’cuda:0’,<br>        grad_fn=<ViewBackward>),<br> tensor([ 0.0310, -2.4748,  0.5816,  0.5764, -1.6917, -0.6970], device=’cuda:0’,<br>        grad_fn=<ViewBackward>))<br>       <img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/VGo5TX7hmnmieEce.png" alt="输入图片说明"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>批量归一化固定小批量中的均值和方差，然后学习出适合的偏移和缩放</li>
<li><strong>可以加速收敛速度，但一般不改变模型精度</strong></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊函数</title>
    <url>/2025/02/26/%E6%A8%A1%E7%B3%8A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>窄带模糊函数</p>
<p>在脉冲雷达和声纳信号处理过程中，模糊函数是传播延迟$\tau$和多普勒频率$f$, $\chi(\tau,f)$的二维函数。它表示由于接收机匹配滤波器[1]</p>
<script type="math/tex; mode=display">
\chi(\tau,f)=\int_{-\infty}^{\infty}s(t)s^{*}(t - \tau)e^{i2\pi ft}dt</script></li>
<li><p>宽带模糊函数给出的定义为[2] [6]</p>
<script type="math/tex; mode=display">
WB_{ss}(\tau,\alpha)=\sqrt{|\alpha|}\int_{-\infty}^{\infty}s(t)s^{*}(\alpha(t - \tau))dt</script><p>其中 $\alpha$是接收信号相对于发射信号的时间尺度因子，计算公式为：</p>
<script type="math/tex; mode=display">
\alpha=\frac{c + v}{c - v}</script></li>
</ul>
<p>实际上宽带模糊函数才是广义形式，因为当介质中的波速远快于目标速度时（这在雷达/声纳中很常见）频率上的这种压缩可通过频率偏移 $f_d = f_c \cdot v/c$（称为多普勒偏移）来近似。而窄带信号可以用这种近似，于是才得出了窄带模糊函数，可以通过利用 FFT 算法高效地计算。</p>
<h2 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h2><p>因为模糊度函数与二维傅里叶变换与 Wigner–Ville 分布相关，所以在时频信号处理领域中发挥着关键作用[3]。这种关系是其他时频分布公式化的基础(比如双线性时频分布是通过对模糊域（即信号的模糊度函数）进行二维滤波获得的），这类分布可能更适合所考虑的信号[4]。 </p>
<p>此外，模糊分布可以看作是使用信号本身作为窗口函数的信号的短时傅里叶变换。这一观察已被用来在时间-尺度域来定义模糊分布,而不是时间-频率域[5]</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="窄带模糊函数"><a href="#窄带模糊函数" class="headerlink" title="窄带模糊函数"></a>窄带模糊函数</h3><p>参考matlab代码，但是绘图时注意截取或者降采样，否则运算量太大</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">waveform = phased.RectangularWaveform;</span><br><span class="line">x = waveform();</span><br><span class="line">PRF = waveform.PRF;</span><br><span class="line">[afmag,delay,doppler] = ambgfun(x,waveform.SampleRate,PRF);</span><br><span class="line">contour(delay,doppler,afmag) <span class="comment">%这里画的是模糊度图</span></span><br><span class="line">xlabel(<span class="string">&quot;Delay (seconds)&quot;</span>)</span><br><span class="line">ylabel(<span class="string">&quot;Doppler Shift (hertz)&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.mathworks.com/help/examples/phased/win64/AmbiguityFunctionOfARectangularPulseExample_01.png" alt="matlab_ambiguity"></p>
<h3 id="宽带模糊函数"><a href="#宽带模糊函数" class="headerlink" title="宽带模糊函数"></a>宽带模糊函数</h3><p>以costas序列为例（使用时注意脉冲长度不能过大，否则resample会出现问题）,请原谅，之前给的代码很复杂，改成这样够精简的了……</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">r=<span class="number">50</span>;b=<span class="number">2</span>;len=<span class="number">7</span>;</span><br><span class="line">c = <span class="number">1500</span>;                  <span class="comment">%参考速度为1500</span></span><br><span class="line">v_range = <span class="number">20</span>;              <span class="comment">%定义速度范围</span></span><br><span class="line">r_range = <span class="number">1000</span>;            <span class="comment">%定义距离范围</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[A, vel]</span> = <span class="title">wideband_ambiguity</span><span class="params">(x1, x2, r, b, len, c, v_range,r_range, fs)</span></span></span><br><span class="line">    rs_bsig1 = resample(x1,<span class="number">1</span>,<span class="number">1</span>);        <span class="comment">%对信号不进行重采样</span></span><br><span class="line">    <span class="comment">% delay</span></span><br><span class="line">    N = <span class="built_in">size</span>(rs_bsig1,<span class="number">2</span>);               <span class="comment">%获取重采样的信号大小</span></span><br><span class="line">    delay = <span class="built_in">round</span>((r_range/c)*fs);         <span class="comment">%TO DO:获取1000m距离</span></span><br><span class="line">    obsvN = delay+N;                    <span class="comment">%obsvN 总的观测的长度</span></span><br><span class="line">    s_n = [rs_bsig1 <span class="built_in">zeros</span>(<span class="number">1</span>,obsvN-N)];  <span class="comment">%s_n 在原始信号后面补零</span></span><br><span class="line">    sig = s_n(<span class="number">1</span>:obsvN-delay);           <span class="comment">%截取的信号</span></span><br><span class="line">    bsig_no = [<span class="built_in">zeros</span>(<span class="number">1</span>,delay) sig];     <span class="comment">%对sig添加延迟</span></span><br><span class="line"></span><br><span class="line">    clear obsvN sig N;</span><br><span class="line"></span><br><span class="line">    vel_del = c/(r*(b^len<span class="number">-1</span>));          <span class="comment">% vel_del 速度分辨率</span></span><br><span class="line">    vel = <span class="number">0</span>:vel_del:v_range;               </span><br><span class="line">    vel = [-vel(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">2</span>) vel];         <span class="comment">% vel 速度范围：其中存储的是不同的速度，包括正负值</span></span><br><span class="line">    eta = <span class="number">1</span>+(vel/c);                    <span class="comment">%获取(1+v/c)的分子和分母</span></span><br><span class="line">    [p,q]= <span class="built_in">rat</span>(eta);                    </span><br><span class="line"></span><br><span class="line">    ambig1 = cell(<span class="number">1</span>, <span class="built_in">length</span>(vel));      <span class="comment">%初始化两个cell数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span>:<span class="built_in">length</span>(vel)  <span class="comment">% 遍历vel速度数组</span></span><br><span class="line">        re_samp_bsig1 = resample(x2,p(<span class="built_in">i</span>),q(<span class="built_in">i</span>));     <span class="comment">% p&gt;q expansion and p&lt;q compression</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------在时域上进行相关处理----------------------------------- </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span>(re_samp_bsig1)&gt;<span class="built_in">length</span>(bsig_no)   <span class="comment">%如果重采样后的信号长度大于延迟信号，补零以匹配长度。</span></span><br><span class="line">            na = <span class="built_in">length</span>(re_samp_bsig1)-<span class="built_in">length</span>(bsig_no);</span><br><span class="line">            bsig_no= [bsig_no <span class="built_in">zeros</span>(<span class="number">1</span>,na+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ambig1&#123;<span class="built_in">i</span>&#125;=  <span class="built_in">abs</span>(matchFilter(bsig_no,re_samp_bsig1,<span class="string">&#x27;none&#x27;</span>));</span><br><span class="line">        nl = <span class="built_in">length</span>(bsig_no);</span><br><span class="line">        ambigh1(<span class="number">1</span>:(nl),<span class="built_in">i</span>) =(ambig1&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    Max1= <span class="built_in">max</span>(<span class="built_in">max</span>(ambigh1));</span><br><span class="line">    A=(<span class="built_in">abs</span>(ambigh1 ./ Max1));</span><br><span class="line"></span><br><span class="line"><span class="comment">%重采样模糊函数</span></span><br><span class="line"><span class="comment">%% resample the ambiguity funnction;</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span>:<span class="built_in">length</span>(vel)</span><br><span class="line">        re_ambigh1(:,<span class="built_in">i</span>)=resample(A(:,<span class="built_in">i</span>),<span class="number">1</span>,<span class="number">6.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    A=re_ambigh1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.helloimg.com/i/2025/02/26/67beb7f9bd2e0.png" alt="costas模糊函数.png"></p>
<p><img src="https://www.helloimg.com/i/2025/02/26/67beb81bd2ce2.png" alt="模糊函数2.png"></p>
<p><strong>参考文献：</strong></p>
<ol>
<li><p><a href="https://en.wikipedia.org/wiki/Philip_Woodward">Woodward P.M.</a> <em>Probability and Information Theory with Applications to Radar</em>, Norwood, MA: Artech House, 1980.</p>
</li>
<li><p>^ <a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-Weiss_2-0">Jump up to:<strong><em>a</em></strong></a> <a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-Weiss_2-1"><strong><em>b</em></strong></a> Weiss, Lora G. “Wavelets and Wideband Correlation Processing”. <em>IEEE Signal Processing Magazine</em>, pp. 13–32, Jan 1994</p>
</li>
<li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-3">^</a></strong> E. Sejdić, I. Djurović, J. Jiang, “Time-frequency feature representation using energy concentration: An overview of recent advances,” <em>Digital Signal Processing</em>, vol. 19, no. 1, pp. 153-183, January 2009.</p>
</li>
<li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-4">^</a></strong> B. Boashash, editor, “Time-Frequency Signal Analysis and Processing – A Comprehensive Reference”, Elsevier Science, Oxford, 2003; <a href="https://en.wikipedia.org/wiki/ISBN_(identifier">ISBN</a>) <a href="https://en.wikipedia.org/wiki/Special:BookSources/0-08-044335-4">0-08-044335-4</a></p>
</li>
<li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-5">^</a></strong> Shenoy, R.G.; Parks, T.W., “Affine Wigner distributions,” IEEE International Conference on Acoustics, Speech, and Signal Processing, ICASSP-92., pp.185-188 vol.5, 23-26 Mar 1992, <a href="https://dx.doi.org/10.1109/ICASSP.1992.226539">doi: 10.1109/ICASSP.1992.226539</a></p>
</li>
<li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-6">^</a></strong> L. Sibul, L. Ziomek, “Generalised wideband crossambiguity function”, IEEE International Conference on Acoustics, Speech, and Signal Processing, ICASSP ‘81.01/05/198105/1981; 6:1239–1242.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信号处理</category>
        <category>模糊函数</category>
      </categories>
      <tags>
        <tag>教学</tag>
        <tag>docs文档</tag>
      </tags>
  </entry>
</search>
