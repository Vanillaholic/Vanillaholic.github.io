<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zane&#39;s Blog</title>
  
  <subtitle>Welcome to my blog , Leave a footprint.</subtitle>
  <link href="https://vanillaholic.github.io/atom.xml" rel="self"/>
  
  <link href="https://vanillaholic.github.io/"/>
  <updated>2025-03-03T10:37:02.913Z</updated>
  <id>https://vanillaholic.github.io/</id>
  
  <author>
    <name>Zane</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用python进行Monte Carlo实验</title>
    <link href="https://vanillaholic.github.io/2025/03/03/Monte%20Carlo%E5%AE%9E%E9%AA%8C/"/>
    <id>https://vanillaholic.github.io/2025/03/03/Monte%20Carlo%E5%AE%9E%E9%AA%8C/</id>
    <published>2025-03-03T05:53:12.000Z</published>
    <updated>2025-03-03T10:37:02.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Monte-Carlo实验">Monte Carlo实验</h2><h3 id="方法一：使用multiprocessing包">方法一：使用multiprocessing包</h3><p>使用python进行monte carlo实验，如下图所示，有16个进程可以设置</p><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031157277.png" alt="img"></p><p>使用模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_trial</span>(<span class="params">trial_idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此处填写实验内容，需要在之前global变量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> success <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    total_epochs = </span><br><span class="line">    <span class="comment">#<span class="doctag">TODO:</span> 导入terminal参数</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Process some arguments.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--snr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=-<span class="number">5</span>, <span class="built_in">help</span>=<span class="string">&#x27;set the signal-noise ratio&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-o&#x27;</span>,<span class="string">&#x27;--output&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;results.txt&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;保存结果的文件名&#x27;</span>)</span><br><span class="line">    <span class="comment"># 解析参数</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 使用 tqdm 显示进度</span></span><br><span class="line">        results = <span class="built_in">list</span>(tqdm(pool.imap(run_trial, <span class="built_in">range</span>(total_epochs)),</span><br><span class="line">                            total=total_epochs, desc=<span class="string">&quot;Running CFAR experiments&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    success_count = <span class="built_in">sum</span>(results)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(args.output, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">f&quot;虚警概率为: <span class="subst">&#123;P_f&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;SNR: <span class="subst">&#123;args.snr&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;蒙特卡洛实验次数: <span class="subst">&#123;total_epochs&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;检测成功次数: <span class="subst">&#123;success_count&#125;</span>\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">f&quot;检测成功率: <span class="subst">&#123;success_count / total_epochs * <span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;---------------------------------------------------------\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结果已保存到 <span class="subst">&#123;args.output&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="方法二：使用cupy（推荐）">方法二：使用cupy（推荐）</h3><p>这个不是默认的，需要额外安装，安装好后按如下步骤调试，即可看运算能力。</p><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031555578.png" alt="img"></p><p>本人使用的是Nvidia-GeForce4060,运算能力是8.9，正好对应</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ca8e73319822a38aa6cf5bd07f04863.png" alt=""></p><p>此包和numpy是镜像的，所以许多函数是通用的，直接使用即可。cupy在默认情况下，所有的数组操作都是在 GPU 上进行的。CuPy 的设计理念是直接在 GPU 上创建和操作数组，因此不需要显式地将数据从 CPU 转移到 GPU。CuPy 的数组（<code>cupy.ndarray</code>）本身就是存储在 GPU 上的，而 NumPy 的数组（<code>numpy.ndarray</code>）是存储在 CPU 上的。输出：&lt;CUDA Device 0&gt;（表示在 GPU 上）</p><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/img/202503031604436.png" alt="image-20250303160400374"></p>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="教学" scheme="https://vanillaholic.github.io/categories/%E6%95%99%E5%AD%A6/"/>
    
    <category term="编程" scheme="https://vanillaholic.github.io/categories/%E6%95%99%E5%AD%A6/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="教学" scheme="https://vanillaholic.github.io/tags/%E6%95%99%E5%AD%A6/"/>
    
    <category term="编程" scheme="https://vanillaholic.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Resnet残差网络</title>
    <link href="https://vanillaholic.github.io/2025/03/02/resnet/"/>
    <id>https://vanillaholic.github.io/2025/03/02/resnet/</id>
    <published>2025-03-02T05:53:12.000Z</published>
    <updated>2025-03-03T10:36:58.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考">思考</h2><p>模型越复杂,是不是带来的好处就越多呢?<br><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/dI1pRe8l19TP1IXf.png" alt="输入图片说明"></p><h2 id="结构">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/z1J3qXEVllDkzTIm.png" alt="输入图片说明"></p><p>残差块家族也有许多成员<br><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/WqbWs8L80xqNc5pu.png" alt="输入图片说明"></p><h3 id="Resnet块">Resnet块</h3><p><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/d47qJCeyNyPB7i85.png" alt="输入图片说明"></p><p>重复多次,就得到了resnet网络</p><h2 id="总结">总结</h2><ul><li>残差块使得很深的网络更加容易训练<ul><li>甚至可以训练一千层的网络</li></ul></li><li>残差网络对随后的深层神经网络设计产生了深远影响，无论是卷积类网络还是全连接类网络</li></ul>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="深度学习" scheme="https://vanillaholic.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://vanillaholic.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>batch norm批量归一化</title>
    <link href="https://vanillaholic.github.io/2025/03/02/%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/"/>
    <id>https://vanillaholic.github.io/2025/03/02/%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/</id>
    <published>2025-03-02T05:53:12.000Z</published>
    <updated>2025-03-03T10:37:20.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>在训练模型的时候,对于一个网络来说:</p><ul><li>前部:数据集中在前部,网络前面的层变化,则会导致后面的层也跟着变化-&gt;收敛速度慢</li><li>后部:损失是集中在网络后面的,所以往往后面的层训练较快<br>那有没有一种方式,使网络后面的层尽量保持不变呢?</li></ul><h2 id="批量归一化">批量归一化</h2><h3 id="定义">定义</h3><p>通过固定小批量数据的均值和方差，再引入可学习参数 γ 和 β 对数据进行调整，有助于加速模型的训练收敛，提高模型的稳定性 。<br>计算小批量均值和方差的公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mi>B</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>B</mi></mrow></munder><msub><mi>x</mi><mi>i</mi></msub><mtext> and </mtext><msubsup><mi>σ</mi><mi>B</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>B</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>B</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\mu_B = \frac{1}{|B|} \sum_{i\in B} x_i \text{ and } \sigma_B^2 = \frac{1}{|B|} \sum_{i\in B} (x_i - \mu_B)^2 + \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.6431em;vertical-align:-1.3217em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> and </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.6431em;vertical-align:-1.3217em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span></p><p>然后对其做额外的调整:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>γ</mi><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>B</mi></msub></mrow><msub><mi>σ</mi><mi>B</mi></msub></mfrac><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">x_{i + 1} = \gamma \frac{x_i - \mu_B}{\sigma_B} + \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0963em;vertical-align:-0.836em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></span></p><p>不再学习均值和方差,转而学习参数 γ 和 β</p><h3 id="作用位置">作用位置</h3><ul><li>作用在<ul><li>全连接层和卷积层输出上，激活函数前</li><li>全连接层和卷积层输入上</li></ul></li><li>对全连接层，作用在特征维</li><li>对于卷积层，作用在通道维</li></ul><h2 id="实现">实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">6</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">                    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">256</span>, <span class="number">120</span>), nn.BatchNorm1d(<span class="number">120</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.BatchNorm1d(<span class="number">84</span>),</span><br><span class="line">                    nn.Sigmoid(), nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>拉伸参数 <code>gamma</code> 和偏移参数 <code>beta</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">1</span>].gamma.reshape((-<span class="number">1</span>,)), net[<span class="number">1</span>].beta.reshape((-<span class="number">1</span>,))</span><br></pre></td></tr></table></figure><p>(tensor([2.1534, 2.1612, 2.0096, 1.9473, 1.8451, 1.3328], device=‘cuda:0’,<br>grad_fn=<ViewBackward>),<br>tensor([ 0.0310, -2.4748,  0.5816,  0.5764, -1.6917, -0.6970], device=‘cuda:0’,<br>grad_fn=<ViewBackward>))<br><img src="https://cdn.jsdelivr.net/gh/vanillaholic/image-bed@main/d2l/VGo5TX7hmnmieEce.png" alt="输入图片说明"></p><h2 id="总结">总结</h2><ul><li>批量归一化固定小批量中的均值和方差，然后学习出适合的偏移和缩放</li><li><strong>可以加速收敛速度，但一般不改变模型精度</strong></li></ul>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="深度学习" scheme="https://vanillaholic.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://vanillaholic.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>模糊函数</title>
    <link href="https://vanillaholic.github.io/2025/02/26/%E6%A8%A1%E7%B3%8A%E5%87%BD%E6%95%B0/"/>
    <id>https://vanillaholic.github.io/2025/02/26/%E6%A8%A1%E7%B3%8A%E5%87%BD%E6%95%B0/</id>
    <published>2025-02-26T06:10:12.000Z</published>
    <updated>2025-03-02T05:44:18.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><ul><li><p>窄带模糊函数</p><p>在脉冲雷达和声纳信号处理过程中，模糊函数是传播延迟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span>和多普勒频率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi(\tau,f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">χ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>的二维函数。它表示由于接收机匹配滤波器[1]</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>χ</mi><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>s</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>τ</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mi>i</mi><mn>2</mn><mi>π</mi><mi>f</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\chi(\tau,f)=\int_{-\infty}^{\infty}s(t)s^{*}(t - \tau)e^{i2\pi ft}dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">χ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p></li><li><p>宽带模糊函数给出的定义为[2] [6]</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><msub><mi>B</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>τ</mi><mo separator="true">,</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mi mathvariant="normal">∣</mi></mrow></msqrt><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>s</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>t</mi><mo>−</mo><mi>τ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">WB_{ss}(\tau,\alpha)=\sqrt{|\alpha|}\int_{-\infty}^{\infty}s(t)s^{*}(\alpha(t - \tau))dt </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9839em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span></span></span><span style="top:-2.9439em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2561em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7387em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">))</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是接收信号相对于发射信号的时间尺度因子，计算公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mo>+</mo><mi>v</mi></mrow><mrow><mi>c</mi><mo>−</mo><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\alpha=\frac{c + v}{c - v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li></ul><p>实际上宽带模糊函数才是广义形式，因为当介质中的波速远快于目标速度时（这在雷达/声纳中很常见）频率上的这种压缩可通过频率偏移 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>d</mi></msub><mo>=</mo><msub><mi>f</mi><mi>c</mi></msub><mo>⋅</mo><mi>v</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">f_d = f_c \cdot v/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>（称为多普勒偏移）来近似。而窄带信号可以用这种近似，于是才得出了窄带模糊函数，可以通过利用 FFT 算法高效地计算。</p><h2 id="物理意义">物理意义</h2><p>因为模糊度函数与二维傅里叶变换与 Wigner–Ville 分布相关，所以在时频信号处理领域中发挥着关键作用[3]。这种关系是其他时频分布公式化的基础(比如双线性时频分布是通过对模糊域（即信号的模糊度函数）进行二维滤波获得的），这类分布可能更适合所考虑的信号[4]。</p><p>此外，模糊分布可以看作是使用信号本身作为窗口函数的信号的短时傅里叶变换。这一观察已被用来在时间-尺度域来定义模糊分布,而不是时间-频率域[5]</p><h2 id="代码">代码</h2><h3 id="窄带模糊函数">窄带模糊函数</h3><p>参考matlab代码，但是绘图时注意截取或者降采样，否则运算量太大</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">waveform = phased.RectangularWaveform;</span><br><span class="line">x = waveform();</span><br><span class="line">PRF = waveform.PRF;</span><br><span class="line">[afmag,delay,doppler] = ambgfun(x,waveform.SampleRate,PRF);</span><br><span class="line">contour(delay,doppler,afmag) <span class="comment">%这里画的是模糊度图</span></span><br><span class="line">xlabel(<span class="string">&quot;Delay (seconds)&quot;</span>)</span><br><span class="line">ylabel(<span class="string">&quot;Doppler Shift (hertz)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://www.mathworks.com/help/examples/phased/win64/AmbiguityFunctionOfARectangularPulseExample_01.png" alt="matlab_ambiguity"></p><h3 id="宽带模糊函数">宽带模糊函数</h3><p>以costas序列为例（使用时注意脉冲长度不能过大，否则resample会出现问题）,请原谅，之前给的代码很复杂，改成这样够精简的了……</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">r=<span class="number">50</span>;b=<span class="number">2</span>;len=<span class="number">7</span>;</span><br><span class="line">c = <span class="number">1500</span>;                  <span class="comment">%参考速度为1500</span></span><br><span class="line">v_range = <span class="number">20</span>;              <span class="comment">%定义速度范围</span></span><br><span class="line">r_range = <span class="number">1000</span>;            <span class="comment">%定义距离范围</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[A, vel]</span> = <span class="title">wideband_ambiguity</span><span class="params">(x1, x2, r, b, len, c, v_range,r_range, fs)</span></span></span><br><span class="line">    rs_bsig1 = resample(x1,<span class="number">1</span>,<span class="number">1</span>);        <span class="comment">%对信号不进行重采样</span></span><br><span class="line">    <span class="comment">% delay</span></span><br><span class="line">    N = <span class="built_in">size</span>(rs_bsig1,<span class="number">2</span>);               <span class="comment">%获取重采样的信号大小</span></span><br><span class="line">    delay = <span class="built_in">round</span>((r_range/c)*fs);         <span class="comment">%TO DO:获取1000m距离</span></span><br><span class="line">    obsvN = delay+N;                    <span class="comment">%obsvN 总的观测的长度</span></span><br><span class="line">    s_n = [rs_bsig1 <span class="built_in">zeros</span>(<span class="number">1</span>,obsvN-N)];  <span class="comment">%s_n 在原始信号后面补零</span></span><br><span class="line">    sig = s_n(<span class="number">1</span>:obsvN-delay);           <span class="comment">%截取的信号</span></span><br><span class="line">    bsig_no = [<span class="built_in">zeros</span>(<span class="number">1</span>,delay) sig];     <span class="comment">%对sig添加延迟</span></span><br><span class="line"></span><br><span class="line">    clear obsvN sig N;</span><br><span class="line"></span><br><span class="line">    vel_del = c/(r*(b^len<span class="number">-1</span>));          <span class="comment">% vel_del 速度分辨率</span></span><br><span class="line">    vel = <span class="number">0</span>:vel_del:v_range;               </span><br><span class="line">    vel = [-vel(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">2</span>) vel];         <span class="comment">% vel 速度范围：其中存储的是不同的速度，包括正负值</span></span><br><span class="line">    eta = <span class="number">1</span>+(vel/c);                    <span class="comment">%获取(1+v/c)的分子和分母</span></span><br><span class="line">    [p,q]= <span class="built_in">rat</span>(eta);                    </span><br><span class="line"></span><br><span class="line">    ambig1 = cell(<span class="number">1</span>, <span class="built_in">length</span>(vel));      <span class="comment">%初始化两个cell数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span>:<span class="built_in">length</span>(vel)  <span class="comment">% 遍历vel速度数组</span></span><br><span class="line">        re_samp_bsig1 = resample(x2,p(<span class="built_in">i</span>),q(<span class="built_in">i</span>));     <span class="comment">% p&gt;q expansion and p&lt;q compression</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------在时域上进行相关处理----------------------------------- </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span>(re_samp_bsig1)&gt;<span class="built_in">length</span>(bsig_no)   <span class="comment">%如果重采样后的信号长度大于延迟信号，补零以匹配长度。</span></span><br><span class="line">            na = <span class="built_in">length</span>(re_samp_bsig1)-<span class="built_in">length</span>(bsig_no);</span><br><span class="line">            bsig_no= [bsig_no <span class="built_in">zeros</span>(<span class="number">1</span>,na+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        ambig1&#123;<span class="built_in">i</span>&#125;=  <span class="built_in">abs</span>(matchFilter(bsig_no,re_samp_bsig1,<span class="string">&#x27;none&#x27;</span>));</span><br><span class="line">        nl = <span class="built_in">length</span>(bsig_no);</span><br><span class="line">        ambigh1(<span class="number">1</span>:(nl),<span class="built_in">i</span>) =(ambig1&#123;<span class="built_in">i</span>&#125;);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    Max1= <span class="built_in">max</span>(<span class="built_in">max</span>(ambigh1));</span><br><span class="line">    A=(<span class="built_in">abs</span>(ambigh1 ./ Max1));</span><br><span class="line"></span><br><span class="line"><span class="comment">%重采样模糊函数</span></span><br><span class="line"><span class="comment">%% resample the ambiguity funnction;</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> =<span class="number">1</span>:<span class="built_in">length</span>(vel)</span><br><span class="line">        re_ambigh1(:,<span class="built_in">i</span>)=resample(A(:,<span class="built_in">i</span>),<span class="number">1</span>,<span class="number">6.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    A=re_ambigh1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://www.helloimg.com/i/2025/02/26/67beb7f9bd2e0.png" alt="costas模糊函数.png"></p><p><img src="https://www.helloimg.com/i/2025/02/26/67beb81bd2ce2.png" alt="模糊函数2.png"></p><p><strong>参考文献：</strong></p><ol><li><p><a href="https://en.wikipedia.org/wiki/Philip_Woodward">Woodward P.M.</a> <em>Probability and Information Theory with Applications to Radar</em>, Norwood, MA: Artech House, 1980.</p></li><li><p>^ <a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-Weiss_2-0">Jump up to:<em><strong>a</strong></em></a> <a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-Weiss_2-1"><em><strong>b</strong></em></a> Weiss, Lora G. “Wavelets and Wideband Correlation Processing”. <em>IEEE Signal Processing Magazine</em>, pp. 13–32, Jan 1994</p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-3">^</a></strong> E. Sejdić, I. Djurović, J. Jiang, “Time-frequency feature representation using energy concentration: An overview of recent advances,” <em>Digital Signal Processing</em>, vol. 19, no. 1, pp. 153-183, January 2009.</p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-4">^</a></strong> B. Boashash, editor, “Time-Frequency Signal Analysis and Processing – A Comprehensive Reference”, Elsevier Science, Oxford, 2003; <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/0-08-044335-4">0-08-044335-4</a></p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-5">^</a></strong> Shenoy, R.G.; Parks, T.W., “Affine Wigner distributions,” IEEE International Conference on Acoustics, Speech, and Signal Processing, ICASSP-92., pp.185-188 vol.5, 23-26 Mar 1992, <a href="https://dx.doi.org/10.1109/ICASSP.1992.226539">doi: 10.1109/ICASSP.1992.226539</a></p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/Ambiguity_function#cite_ref-6">^</a></strong> L. Sibul, L. Ziomek, “Generalised wideband crossambiguity function”, IEEE International Conference on Acoustics, Speech, and Signal Processing, ICASSP '81.01/05/198105/1981; 6:1239–1242.</p></li></ol>]]></content>
    
    
    <summary type="html">介绍了模糊函数</summary>
    
    
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="模糊函数" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E6%A8%A1%E7%B3%8A%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="教学" scheme="https://vanillaholic.github.io/tags/%E6%95%99%E5%AD%A6/"/>
    
    <category term="docs文档" scheme="https://vanillaholic.github.io/tags/docs%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>DL-CFAR检测算法</title>
    <link href="https://vanillaholic.github.io/2025/02/25/DL-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://vanillaholic.github.io/2025/02/25/DL-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2025-02-25T09:54:06.000Z</published>
    <updated>2025-02-28T18:25:23.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文随笔-利用深度学习进行恒虚警检测">论文随笔-利用深度学习进行恒虚警检测</h2><h2 id="引言">引言</h2><p>之前已经提及，常用的CFAR一共有四种方法，但是都有一定的限制，CA-CFAR[1] 利用参考单元功率的算术平均值作为噪声水平估计值。它的一个变种，即单元平均恒定虚警率（GOCA-CFAR）[2]，可以提高原始方案的虚警率。虽然这两种方案在同质场景中表现良好，但在多目标场景中，它们的性能会因错误的噪声水平估计而下降。为了提高多目标场景下的性能，有人提出了最小单元平均 CFAR（SOCA-CFAR）[3]。然而，它在密集多目标场景中并不能显著提高性能。有序统计 CFAR（OS-CFAR）[4] 可以处理这类问题，但它带来了显著的计算复杂性.</p><h2 id="一、复习">一、复习</h2><h3 id="1-RDM的获取">1.RDM的获取</h3><p>以 FMCW 雷达为例，发射一个由 M 个啁啾（啁啾是频率随时间线性增加的正弦波）组成的帧，然后以逐个啁啾的方式将发射和接收的啁啾混合成 M 个中频（IF）信号。然后，我们在每个啁啾信号中提取 N 个中频信号样本，并使用预定的采样周期。如图所示，CCM 由这些逐个啁啾采样的级联列构成。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf99ac06.png" alt="RDM生成.png"></p><p>对信道系数矩阵CCM进行二维FFT，就能获得RDM图。公式如下</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>RDM</mtext><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mrow><mo fence="true">∣</mo><mn>2</mn><mtext>D FFT</mtext><mo stretchy="false">(</mo><mi mathvariant="bold">H</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo fence="true">∣</mo></mrow><mn>2</mn></msup><mspace linebreak="newline"></mspace><mo>=</mo><msup><mrow><mo fence="true">∣</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><mi mathvariant="bold">H</mi><msub><mo stretchy="false">)</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>π</mi><mi>l</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>M</mi></mrow></msup><msup><mi>e</mi><mrow><mi>j</mi><mn>2</mn><mi>π</mi><mi>k</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow></msup><mo fence="true">∣</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\text{RDM}(n,m) = \left| 2\text{D FFT}(\mathbf{H})(n,m) \right|^2 \\= \left| \sum_{k=0}^{N-1} \sum_{l=0}^{M-1} (\mathbf{H})_{k,l} e^{j2\pi lm/M} e^{j2\pi kn/N} \right|^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">RDM</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord">2</span><span class="mord text"><span class="mord">D FFT</span></span><span class="mopen">(</span><span class="mord mathbf">H</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.3345em;vertical-align:-1.3021em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:5em;"></span><span style="width:0.333em;height:3.000em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.333em" height="3.000em" viewBox="0 0 333 3000"><path d="M145 15 v585 v1800 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1800 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1800 v585 h43z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">H</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">πkn</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:5em;"></span><span style="width:0.333em;height:3.000em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.333em" height="3.000em" viewBox="0 0 333 3000"><path d="M145 15 v585 v1800 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1800 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1800 v585 h43z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.0323em;"><span style="top:-4.2812em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>在进行RDM处理后，会获取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>l</mi><mi>o</mi><mi>g</mi><mn>10</mn><mo stretchy="false">(</mo><mi>N</mi><mo>×</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">10log10(N\times M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">10</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>的增益，以便于识别目标 。</p><h3 id="2-CFAR">2.CFAR</h3><p>一种判断是否存在目标，而2D-CFAR不仅能获取方位信息，还能同时获取速度信息</p><h2 id="二、DL-CFAR介绍">二、DL-CFAR介绍</h2><p>设要处理的RDM大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>w</mi></msub><mo>×</mo><msub><mi>M</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">{N_w}\times{M_w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>,首先将RDM截断(此处可以看作目标+噪声)，然后输入进网络，要注意的是，神经网络并不是进行目标识别，而是估计出所截断的RDM的噪声水平。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9d8d64.png" alt="DL模型.png"></p><h2 id="三、实现过程">三、实现过程</h2><h3 id="1-数据预处理">1.数据预处理</h3><p>截断处理原因：由于归一化的原因，噪声接近于0</p><h3 id="2-网络结构">2. 网络结构</h3><p>如图所示，自定义的残差块+自定义的残差块+全连接层+全连接层+激活函数ReLU</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf967233.png" alt="网络结构.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLCFAR</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DLCFAR, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.res_block1 = ResidualBlock(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.res_block2 = ResidualBlock(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">16</span> * <span class="number">1</span>, <span class="number">512</span>)  <span class="comment"># Assuming input size is (16, 16, 1)</span></span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">512</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.res_block1(x)</span><br><span class="line">        x = F.prelu(x)  <span class="comment"># PReLU activation</span></span><br><span class="line">        x = <span class="variable language_">self</span>.res_block2(x)</span><br><span class="line">        x = F.prelu(x)  <span class="comment"># PReLU activation</span></span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>该网络特点：设计神经网络时不包含任何池化层，因为希望保留 RDM的所有信息，以精确估计噪声水平。</p><h3 id="3-训练方式">3.训练方式</h3><ul><li>损失函数：MSE</li><li>优化器：Adam</li><li>初始学习率：0.00005</li><li>batch_size:128</li><li>训练次数：500</li><li>训练数据集的样本数为 40000 ，验证和测试数据集的样本数均为 200000</li></ul><h3 id="4-性能">4.性能</h3><p>在较高信噪比和较低信噪比的时候，性能会有所下降。下图为测试结果偏差和标准差，加粗的是该组中性能能好的。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d1a430.png" alt="性能.png"></p><p>代码：（原作者<a href="https://github.com/Vanillaholic/DL_CFAR_data/commits?author=paulchen2713">paulchen2713</a>）</p><p>数据生成：<a href="https://github.com/Vanillaholic/DL_CFAR_data">https://github.com/Vanillaholic/DL_CFAR_data</a></p><p>目标检测：<a href="https://github.com/Vanillaholic/DL_CFAR">https://github.com/Vanillaholic/DL_CFAR</a></p><p>参考文献:</p><p>[1] C. R. Barrett, Adaptive thresholding and automatic detection.Boston, MA: Springer US, 1987, pp. 368–393. [Online]. Available:<br><a href="https://doi.org/10.1007/978-1-4613-1971-912">https://doi.org/10.1007/978-1-4613-1971-912</a></p><p>[2] V. G. Hansen and J. H. Sawyers, “Detectability loss due to ”greatest of”selection in a cell-averaging cfar,” IEEE Trans. Aerosp. Electron. Syst.,vol. AES-16, no. 1, pp. 115–118, Jan. 1980</p><p>[3] G. V. Trunk, “Range resolution of targets using automatic detectors,”IEEE Trans. Aeros. Electron. Syst., vol. AES-14, no. 5, pp. 750–755,Sept. 1978.</p><p>[4] J. T. Rickard and G. M. Dillard, “Adaptive detection algorithms formultiple-target situations,” IEEE Trans. Aeros. Electron. Syst., vol. AES-13, no. 4, pp. 338–343, July 1977.</p><!--stackedit_data:eyJoaXN0b3J5IjpbLTU3NTEyMDQ0OF19-->]]></content>
    
    
    <summary type="html">利用深度学习进行CFAR</summary>
    
    
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="CFAR" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/CFAR/"/>
    
    <category term="深度学习" scheme="https://vanillaholic.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="雷达/声纳" scheme="https://vanillaholic.github.io/tags/%E9%9B%B7%E8%BE%BE-%E5%A3%B0%E7%BA%B3/"/>
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>四种通信序列</title>
    <link href="https://vanillaholic.github.io/2025/02/25/%E5%9B%9B%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97/"/>
    <id>https://vanillaholic.github.io/2025/02/25/%E5%9B%9B%E7%A7%8D%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97/</id>
    <published>2025-02-25T02:16:00.000Z</published>
    <updated>2025-02-28T18:25:23.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Costas序列（常用在跳频中）">一、Costas序列（常用在跳频中）</h2><p>在数学中，Costas 数组可以在几何上视为 n 个点的集合，每个点位于 n×n 方块平铺中一个正方形的中心，使得每一行或每一列仅包含一个点，并且每对点之间的 n(n − 1)/2 个位移向量都是不同的。这导致了一个理想的“图钉”自模糊函数，使得这些数组在声纳和雷达等应用中非常有用。可以由对数Welch方法构建。[4]</p><p>下图是N=4的costas矩阵</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdf6717b.png" alt="costas序列.png"></p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdfd59df.png" alt="costas信号.png"></p><p>这个代码老师没给，仿真时直接上网查输进去的QAQ，但是给了一本书《Radar Signals》(Nadav Leavnopn, Eli Mozaeeson)（这本书年龄比我爷爷都大……），本人用了，一堆报错，真服了……以下是修改改后的代码[10]</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">positions</span> = <span class="title">costas</span><span class="params">(N)</span></span></span><br><span class="line"><span class="comment">% 修复后的函数，修正本原元判断逻辑</span></span><br><span class="line"></span><br><span class="line">positions = [];</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isprime</span>(N+<span class="number">1</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">1</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 1</span></span><br><span class="line">    p = N+<span class="number">1</span>;</span><br><span class="line">    primitive_roots = [];</span><br><span class="line">    <span class="keyword">for</span> e = <span class="number">2</span>:p<span class="number">-1</span></span><br><span class="line">        powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">            primitive_roots = [primitive_roots; e];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(primitive_roots)</span><br><span class="line">        positions = <span class="built_in">zeros</span>(<span class="built_in">length</span>(primitive_roots), p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(primitive_roots)</span><br><span class="line">            e = primitive_roots(<span class="built_in">i</span>);</span><br><span class="line">            positions(<span class="built_in">i</span>, :) = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">isprime</span>(N+<span class="number">2</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">2</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 2</span></span><br><span class="line">    p = N+<span class="number">2</span>;</span><br><span class="line">    primitive_roots = [];</span><br><span class="line">    <span class="keyword">for</span> e = <span class="number">2</span>:p<span class="number">-1</span></span><br><span class="line">        powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">        <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">            primitive_roots = [primitive_roots; e];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isempty</span>(primitive_roots)</span><br><span class="line">        positions = <span class="built_in">zeros</span>(<span class="built_in">length</span>(primitive_roots), N);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(primitive_roots)</span><br><span class="line">            e = primitive_roots(<span class="built_in">i</span>);</span><br><span class="line">            freq_sequence = <span class="built_in">mod</span>(e.^(<span class="number">2</span>:p<span class="number">-1</span>), p) - <span class="number">1</span>;</span><br><span class="line">            positions(<span class="built_in">i</span>, :) = freq_sequence;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">isprime</span>(N+<span class="number">3</span>) &amp;&amp; <span class="built_in">rem</span>(N+<span class="number">3</span>,<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">% Type 3 (检查2是否为GF(p)的本原元)</span></span><br><span class="line">    p = N+<span class="number">3</span>;</span><br><span class="line">    e = <span class="number">2</span>;</span><br><span class="line">    powers = <span class="built_in">mod</span>(e.^(<span class="number">1</span>:p<span class="number">-1</span>), p);</span><br><span class="line">    <span class="keyword">if</span> all(powers(<span class="number">1</span>:p<span class="number">-2</span>) ~= <span class="number">1</span>) &amp;&amp; powers(p<span class="number">-1</span>) == <span class="number">1</span></span><br><span class="line">        positions = <span class="built_in">mod</span>(e.^(<span class="number">3</span>:p<span class="number">-1</span>), p) - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>函数中使用了 Welch 构造方法，这是一种常用的构造 Costas 数组的方法。</li><li>函数中还涉及到有限域（GF(p)）的概念，这是数学和密码学中的一个概念，用于确定哪些元素是原始元素。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">positions = costas(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><strong>典型的应用案例</strong>：</p><table><thead><tr><th>N</th><th>构造类型</th><th>应用领域</th><th>示例序列（部分）</th><th>来源</th></tr></thead><tbody><tr><td>4</td><td>Welch1</td><td>通信跳频</td><td><code>[2,4,3,1]</code> 或 <code>[3,4,2,1]</code></td><td>[7] [8]</td></tr><tr><td>10</td><td>Welch1</td><td>雷达抗干扰</td><td><code>[2,4,8,5,10,9,7,3,6,1]</code></td><td>[8]</td></tr><tr><td>29</td><td>未明确</td><td>高频声纳</td><td><code>[3,21,23,...,25]</code>（29元素序列）</td><td>[8]</td></tr><tr><td>15</td><td>Welch2</td><td>密码学中的密钥序列生成</td><td>基于GF(17)生成</td><td>[9]</td></tr></tbody></table><p>接下来介绍的都是相位编码</p><h2 id="二、m序列">二、m序列</h2><ul><li>m序列是最大长度序列的简称（Maximum length sequence，MLS） ，就是线性以为寄存器通过线性反馈产生的最长序列，规定级数为r时，产生的码序列为<img src="https://latex.csdn.net/eq?n%3D2%5Er-1" alt="n=2^r-1"></li><li>MLS的实际应用包括测量脉冲响应（例如，房间混响或来自海洋拖曳源的到达时间 [1]）,此外还可作为伪随机序列用于直接序列扩频和跳频传输的数字通信系统中。[2]</li></ul><h3 id="1-m序列的生成">1.m序列的生成</h3><p><strong>假设生成多项式是<img src="https://latex.csdn.net/eq?h%28x%29%3D1*x%5E3+0*x%5E2+0*x%5E1+1*x%5E0" alt="h(x)=1x^3+0x^2+0x^1+1x^0">,则移位器如图所示，若移位器系数为1，则之前的线路与异或器相连，如果为0则不相连。</strong></p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdfb507c.png" alt="m序列.png"></p><p>MLS 是通过最大线性反馈移位寄存器生成的。下图显示了一个具有长度为 4 的移位寄存器的 MLS 生成系统。它可以用以下递归关系表示：</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bdf6deea.png" alt="m序列递归关系.png"></p><p>其中 n 是时间索引， + 表示模2 加法。对于比特值 0 = FALSE 或 1 = TRUE，这相当于异或操作。</p><p>此处有介绍的视频：<a href="https://www.bilibili.com/video/BV1BG411k7ws/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a8bad5c878a2bca5d3412ea36a22a7ea">通信原理4.6.1m序列_哔哩哔哩_bilibili</a></p><p>代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seq = m_seq(oct)</span></span><br><span class="line"><span class="comment">% Generates an m-sequence using generator given by oct.</span></span><br><span class="line"><span class="comment">% Reference:  Dilip V. Sarwate and Michael B. Pursley, 1980. pp. 599. Fig.1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">m = <span class="number">5</span> ; l = <span class="number">2</span>^m<span class="number">-1</span> ; <span class="comment">%阶数：5  </span></span><br><span class="line">oct1 = <span class="number">45</span> ;</span><br><span class="line">gen1  = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>] ;<span class="comment">%生成多项式</span></span><br><span class="line">mseq1 = m_seq(oct1,gen1);<span class="comment">%生成m序列</span></span><br></pre></td></tr></table></figure><h3 id="2-m序列属性">2.m序列属性</h3><ol><li>0和1的数量大致相同</li><li>MLS 的线性自相关近似于δ函数[3]</li></ol><h3 id="3-脉冲响应的提取">3. 脉冲响应的提取</h3><p>如果系统的冲激响应是 h[n]，而 MLS 是 s[n]，那么</p><img src="https://latex.csdn.net/eq?y%5Bn%5D%3Dh%5Bn%5D*s%5Bn%5D" alt="y[n]=h[n]*s[n]"  /><p>对两边与s[n]进行相关处理</p><p><img src="https://latex.csdn.net/eq?%5Cphi_%7Bsy%7D%3Dh%5Bn%5D*%5Cphi%7Bss%7D" alt="hi_{sy}=h[n]*hi{ss}"></p><p>由于性质2，当长度足够长时，<img src="https://latex.csdn.net/eq?%5Cphi_%7Bss%7D" alt="hi_{ss}">近似为一个冲击函数，所以s[n]与y[n]的互相关就是脉冲响应</p><p><img src="https://latex.csdn.net/eq?h%5Bn%5D%3D%5Cphi_%7Bsy%7D" alt="h[n]=hi_{sy}"></p><p><a href="https://readit.site/a/XYlZG/Maximum_length_sequence">https://readit.site/a/XYlZG/Maximum_length_sequence</a></p><h2 id="三、Gold序列">三、Gold序列</h2><p>Gold序列常用于CDMA[5]和GPS卫星导航[6]</p><blockquote><p>Gold codes have bounded small <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlations</a> within a set, <strong>which is useful when multiple devices are broadcasting in the same frequency range.</strong></p></blockquote><p>引文所说，在一个集合内，互相关性能很小，因此在同意同一频带多用户同通信时很有用</p><p>Gold序列的互相关极大值</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7be0b0430.png" alt="gold序列相关.png"></p><h3 id="1-Gold序列的生成">1.Gold序列的生成</h3><p><strong>gold序列是由两个M序列异或得到</strong></p><p><a href="https://readit.site/a/popNM/Gold_code">https://readit.site/a/popNM/Gold_code</a></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqs</span> = <span class="title">gold</span><span class="params">(oct1,gen)</span></span></span><br><span class="line"><span class="comment">% 此函数用于生成gold序列，输入参数为oct1：和gen：生成多项式系数</span></span><br><span class="line"><span class="comment">% function seqs = gold(oct1)</span></span><br><span class="line"><span class="comment">% This function generates N+2=2^n+1 Gold sequences when (n mod 4 != 0);</span></span><br><span class="line"><span class="comment">% and N+1=2^n Gold-like sequences when (n mod 4 == 0).</span></span><br><span class="line"><span class="comment">% oct1 is the generator polynomial in oct form.</span></span><br><span class="line"><span class="comment">% reference: Dilip V. Sarwate and Michael B. Pursley, 1980.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% some equavalent generators.</span></span><br><span class="line"><span class="comment">% m=3, 13</span></span><br><span class="line"><span class="comment">% m=4, 23</span></span><br><span class="line"><span class="comment">% m=5, 45</span></span><br><span class="line"><span class="comment">% m=6, 103</span></span><br><span class="line"><span class="comment">% m=7, 211</span></span><br><span class="line"></span><br><span class="line">u = m_seq(oct1,gen);</span><br><span class="line">N = <span class="built_in">size</span>(u, <span class="number">2</span>);</span><br><span class="line">n = <span class="built_in">log2</span>(N+<span class="number">1</span>);</span><br><span class="line">t = <span class="number">1</span> + <span class="number">2</span>^(<span class="built_in">floor</span>(n/<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">v = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">4</span>) ~=<span class="number">0</span></span><br><span class="line">        seqs = [u; v];</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">                v = rshift(v);</span><br><span class="line">                seqs = [seqs; xor(u, v)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(<span class="number">1</span>, <span class="string">&#x27;Gold sequences\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        seqs = [u];</span><br><span class="line">        v1 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">2</span>);</span><br><span class="line">        v2 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N/<span class="number">3</span></span><br><span class="line">                seqs = [seqs; xor(u, v); xor(u, v1); xor(u, v2)];      </span><br><span class="line">                v = rshift(v); v1 = rshift(v1); v2 = rshift(v2);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fprintf(<span class="number">1</span>, <span class="string">&#x27;Gold-like sequences\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seq = m_seq(oct)</span></span><br><span class="line"><span class="comment">% Generates an m-sequence using generator given by oct.</span></span><br><span class="line"><span class="comment">% Reference:  Dilip V. Sarwate and Michael B. Pursley, 1980. pp. 599. Fig.1.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">rshift</span><span class="params">(x)</span></span></span><br><span class="line">y = [x(:, <span class="keyword">end</span>), x(:, <span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)];</span><br><span class="line"></span><br><span class="line">m = <span class="number">5</span> ; l = <span class="number">2</span>^m<span class="number">-1</span> ; <span class="comment">%阶数：5  </span></span><br><span class="line">oct1 = <span class="number">45</span> ;</span><br><span class="line">gen  = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>] ;<span class="comment">%生成多项式</span></span><br><span class="line">seqs = gold(oct1,gen);<span class="comment">%生成gold序列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gold1 = seqs(<span class="number">1</span>,:);</span><br><span class="line">gold2 = seqs(<span class="number">15</span>,:);</span><br><span class="line">gold3 = seqs(<span class="number">30</span>,:);</span><br></pre></td></tr></table></figure><h2 id="四、Kasami序列">四、Kasami序列</h2><p>Kasami 序列是长度为 2 <em>N</em> −1 的二进制序列，其中 N 是偶整数。Kasami 序列具有良好的交叉相关值，接近 Welch 下界。Kasami 序列分为两类——小集和大集。</p><h3 id="1kasami序列的生成：">1kasami序列的生成：</h3><ol><li><strong>选择两个不同的M序列</strong>： Kasami序列通常由两个长度相同的M序列（最大长度序列）生成。第一个M序列的生成通常使用一个基准的反馈多项式，而第二个M序列则通过将第一个序列进行适当的位移来获得。</li><li><strong>通过异或操作生成Kasami序列</strong>： 通过将这两个M序列进行异或操作得到Kasami序列。对于一个给定的序列，可以通过改变异或操作的位置（即通过移位）来生成多个Kasami序列。</li></ol><p>eg. 假设我们要生成一个长度为15的Kasami序列，使用两个4阶M序列。</p><h4 id="步骤1：生成两个M序列">步骤1：生成两个M序列</h4><p>假设两个M序列的生成多项式分别为：</p><ul><li><code>P1 = x^4 + x + 1</code>，对应的反馈结构生成M序列 <code>M1</code>。</li><li><code>P2 = x^4 + x^3 + 1</code>，对应的反馈结构生成M序列 <code>M2</code></li></ul><h4 id="步骤2：生成Kasami序列">步骤2：生成Kasami序列</h4><p>选择一个移位值 <code>d</code>（例如，<code>d = 3</code>），然后将第二个M序列 <code>M2</code> 进行移位并与 <code>M1</code> 异或，生成Kasami序列。 就获得了长度为15的kasami序列</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seqs</span> = <span class="title">lkasami</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% function seqs = lkasami(oct)</span></span><br><span class="line"><span class="comment">% This function generates Large Kasami sequences.</span></span><br><span class="line"><span class="comment">% oct generate an m-sequence of period 2^n-1</span></span><br><span class="line"><span class="comment">% oct should be in oct form. n should be even.</span></span><br><span class="line"><span class="comment">% The first (N+1)^(0.5) sequences are the small set Kasami sequences. </span></span><br><span class="line"><span class="comment">% reference: Dilip V. Sarwate and Michael B. Pursley, 1980.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Qinghua Zhao</span></span><br><span class="line"><span class="comment">% Aug. 2001 at UCSD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%1.先生成m序列</span></span><br><span class="line">seqs = [];</span><br><span class="line">u = m_seq(oct,gen);</span><br><span class="line">N = <span class="built_in">size</span>(u, <span class="number">2</span>); </span><br><span class="line">n = <span class="built_in">log2</span>(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">2</span>) ~= <span class="number">0</span></span><br><span class="line">fprintf(<span class="number">1</span>, <span class="string">&#x27;No Kasami sequence exist for generator of this order.\n&#x27;</span>);</span><br><span class="line">beep;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">t = <span class="number">1</span> + <span class="number">2</span>^(n/<span class="number">2</span>+<span class="number">1</span>); <span class="comment">% no need to take floor since it will be an interger.</span></span><br><span class="line">v = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% generate w</span></span><br><span class="line">N_2 = <span class="number">2</span>^(n/<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">w = u(<span class="number">1</span>:N_2:<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">if</span> sum(w)==<span class="number">0</span> <span class="comment">% if all zero sequence, then pick another one. It won&#x27;t be all one sequence since it can only be an m-sequence. </span></span><br><span class="line">w = u(<span class="number">2</span>:N_2:<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">w = <span class="built_in">ones</span>(N_2, <span class="number">1</span>)*w;</span><br><span class="line">w = <span class="built_in">reshape</span>(w&#x27;, <span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">fprintf(<span class="number">1</span>, <span class="string">&#x27;First %d sequences are small set Kasami\n&#x27;</span>, N_2<span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(n, <span class="number">4</span>) ~= <span class="number">0</span></span><br><span class="line"><span class="comment">% generate gold sequences </span></span><br><span class="line">G_uv = [u; v];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N</span><br><span class="line">        G_uv = [G_uv; xor(u, v)];</span><br><span class="line">        v = rshift(v);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% generate kasami sequences</span></span><br><span class="line"><span class="comment">% the first 2^(n/2) sequences are the small set kasami sequences.</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(G_uv, <span class="number">1</span>)</span><br><span class="line">seqs = [seqs; G_uv(k,:)];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N_2<span class="number">-2</span></span><br><span class="line">        seqs = [seqs; xor(G_uv(k,:), w)];</span><br><span class="line">        w = rshift(w);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">% generate gold like sequences</span></span><br><span class="line">v1 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">2</span>);</span><br><span class="line">v2 = u(<span class="built_in">mod</span>(<span class="number">0</span>:t:N*t<span class="number">-1</span>, N)+<span class="number">3</span>);</span><br><span class="line">Ht_u = u;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N/<span class="number">3</span></span><br><span class="line"> Ht_u = [Ht_u; xor(u, v); xor(u, v1); xor(u, v2)];</span><br><span class="line">        v = rshift(v); v1 = rshift(v1); v2 = rshift(v2);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% generate kasami sequences</span></span><br><span class="line"><span class="comment">% the first 2^(n/2) sequences are the small set kasami sequences.</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">size</span>(Ht_u, <span class="number">1</span>)</span><br><span class="line">seqs = [seqs; Ht_u(k,:)];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N_2<span class="number">-2</span></span><br><span class="line">        seqs = [seqs; xor(Ht_u(k,:), w)];</span><br><span class="line">        w = rshift(w);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:(N_2<span class="number">-2</span>)/<span class="number">3</span></span><br><span class="line">seqs = [seqs; xor(v, w); xor(v1, w); xor(v2, w)];</span><br><span class="line">        w = rshift(w);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 该函数用于生成m序列，基于给定的生成器oct。</span></span><br><span class="line"><span class="comment">% 参考文献：Dilip V. Sarwate和Michael B. Pursley，1980年。第599页。图1。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seq</span> = <span class="title">m_seq</span><span class="params">(oct,gen)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% gen = oct2gen(oct);     % oct2gen may be removed from future version</span></span><br><span class="line"><span class="comment">%1.查找非零索引，并将序列从该位置之后的位置提取出来</span></span><br><span class="line">s = <span class="built_in">min</span>(<span class="built_in">find</span>(gen));</span><br><span class="line">gen = gen(s+<span class="number">1</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%2.计算生成器的位数和序列的长度</span></span><br><span class="line">n = <span class="built_in">size</span>(gen, <span class="number">2</span>);</span><br><span class="line">N = <span class="number">2</span>^n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%3.将生成器反转</span></span><br><span class="line">gen = <span class="built_in">fliplr</span>(gen);</span><br><span class="line"></span><br><span class="line">seq = <span class="built_in">zeros</span>(<span class="number">1</span>, n); seq(n) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N-n</span><br><span class="line">        next_bit = <span class="built_in">mod</span>(sum(seq(<span class="built_in">i</span>:<span class="built_in">i</span>+n<span class="number">-1</span>)&amp;gen), <span class="number">2</span>);</span><br><span class="line">        seq = [seq, next_bit];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">rshift</span><span class="params">(x)</span></span></span><br><span class="line">y = [x(:, <span class="keyword">end</span>), x(:, <span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)];</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m=<span class="number">4</span>; </span><br><span class="line">oct = <span class="number">23</span>;</span><br><span class="line">gen = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">seqs = lkasami(oct,gen);<span class="comment">%生成gold序列</span></span><br><span class="line">kasami1 = seqs(<span class="number">6</span>,:);</span><br><span class="line">kasami2 = seqs(<span class="number">15</span>,:);</span><br></pre></td></tr></table></figure><h2 id="五、其它编码">五、其它编码</h2><ul><li><p>Phase-Coded Pulse: Barker码</p></li><li><p>Chirplike Phase Codes:</p><ul><li>Frank Code</li><li>P1,P2和Px Codes</li><li>Zadoff-Chu Code</li><li>Golomb Polyphase Codes</li></ul></li><li><p><strong>Huffman Code</strong></p></li></ul><h2 id="附上常用的本征多项式：">附上常用的本征多项式：</h2><p><img src="https://www.helloimg.com/i/2025/02/26/67be7be1ef382.png" alt="本征多项式.png"></p><p><strong>参考文章：</strong></p><p>[1] Gemba, Kay L.; Vazquez, Heriberto J.; Fialkowski, Joseph; Edelmann, Geoffrey F.; Dzieciuch, Matthew A.; Hodgkiss, William S. (October 2021). <a href="https://asa.scitation.org/doi/10.1121/10.0006656">“A performance comparison between m-sequences and linear frequency-modulated sweeps for the estimation of travel-time with a moving source”</a>. <em>The Journal of the Acoustical Society of America</em>. <strong>150</strong> (4): 2613–2623. <a href="https://en.wikipedia.org/wiki/Bibcode_(identifier)">Bibcode</a>:<a href="https://ui.adsabs.harvard.edu/abs/2021ASAJ..150.2613G">2021ASAJ…150.2613G</a>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1121%2F10.0006656">10.1121/10.0006656</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)">PMID</a> <a href="https://pubmed.ncbi.nlm.nih.gov/34717519">34717519</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)">S2CID</a> <a href="https://api.semanticscholar.org/CorpusID:240355915">240355915</a>.</p><p>[2] Buracas GT, Boynton GM (July 2002). “Efficient design of event-related fMRI experiments using M-sequences”. <em>NeuroImage</em>. <strong>16</strong> (3 Pt 1): 801–13. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)">doi</a>:<a href="https://doi.org/10.1006%2Fnimg.2002.1116">10.1006/nimg.2002.1116</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)">PMID</a> <a href="https://pubmed.ncbi.nlm.nih.gov/12169264">12169264</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)">S2CID</a> <a href="https://api.semanticscholar.org/CorpusID:7433120">7433120</a>.</p><p>[3] Jacobsen, Finn; Juhl, Peter Moller (2013-06-04). <a href="https://books.google.com/books?id=Sq6uFqlHg1gC">Fundamentals of General Linear Acoustics</a>. John Wiley &amp; Sons. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-1118636176">978-1118636176</a>. A maximum-length sequence is a binary sequence whose circular autocorrelation (except for a small DC-error) is a delta function.</p><p>[4] <a href="https://en.wikipedia.org/wiki/Costas_array#CITEREFCostas1965">Costas (1965)</a>; <a href="https://en.wikipedia.org/wiki/Costas_array#CITEREFGilbert1965">Gilbert (1965)</a>; <a href="http://nanoexplanations.wordpress.com/2011/10/09/an-independent-discovery-of-costas-arrays/">An independent discovery of Costas arrays</a>, Aaron Sterling, October 9, 2011.</p><p>[5] George, Maria; Hamid, Mujtaba; Miller, Andy (2001-01-10). <a href="https://web.archive.org/web/20080705134550/http://www.xilinx.com/support/documentation/application_notes/xapp217.pdf">“Gold Code Generators in Virtex Devices”</a> (PDF). <em>Virtex Series, Virtex-II Series, and Spartan-II family</em> (Application note). 1.1. <a href="https://en.wikipedia.org/wiki/Xilinx">Xilinx</a>. XAPP217. Archived from <a href="http://www.xilinx.com/support/documentation/application_notes/xapp217.pdf">the original</a> (PDF) on 2008-07-05. (9 pages)</p><p>[6] <a href="https://archive.today/20120804185510/http://www.kowoma.de/en/gps/signals.htm">“Transmitted GPS Signals”</a>. <em>The GPS System</em>. kowoma GPS. 2009-04-19. Archived from <a href="http://www.kowoma.de/en/gps/signals.htm">the original</a> on 2012-08-04.</p><p>[7] GOLOMB S W, TAYLOR H. Constructions and properties of Costas arrays[J/OL]. Proceedings of the IEEE, 1984: 1143-1163. <a href="https://doi.org/10.1109/proc.1984.12994">https://doi.org/10.1109/proc.1984.12994</a>. DOI:10.1109/proc.1984.12994.</p><p>[8] <a href="https://blogs.mathworks.com/steve/2007/02/15/costas-arrays/">https://blogs.mathworks.com/steve/2007/02/15/costas-arrays/</a></p><p>[9]KEN TAYLOR,SCOTT RICKARD,KONSTANTINOS DRAKAKIS．Costas Arrays: Survey, Standardization, and MATLAB Toolbox[J]．ACM transactions on mathematical software,2011,37(4):p.38:59-38:89</p><p>[10] Levanon, Nadav, E. Mozeson, R. Signals and Chaim Levanon. “RADAR SIGNALS.” (2013).</p><!--stackedit_data:eyJoaXN0b3J5IjpbLTg0NDk2NjQxXX0=-->]]></content>
    
    
    <summary type="html">介绍了四种通信中常用的相位编码</summary>
    
    
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="编码" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="雷达/声纳" scheme="https://vanillaholic.github.io/tags/%E9%9B%B7%E8%BE%BE-%E5%A3%B0%E7%BA%B3/"/>
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2D-CFAR检测算法</title>
    <link href="https://vanillaholic.github.io/2025/02/24/2D-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://vanillaholic.github.io/2025/02/24/2D-CFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2025-02-24T11:26:50.000Z</published>
    <updated>2025-02-28T18:25:23.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、内容复习">一、内容复习</h2><p>CFAR检测算法属于信号检测中的自动检测算法，在雷达信号处理中主要应用的有三种，即CA-CFAR、SO-CFAR、GO-CFAR，这三种也是初学者最常采用的算法，要求每一个雷达工程师必须掌握其基本原理，如表所示，其中OS-CFAR一般不常用。</p><table><thead><tr><th>CFAR 类型</th><th>参考电平 Z</th><th>适用场合</th><th>缺点</th></tr></thead><tbody><tr><td>CA-CFAR</td><td>(X+Y)/2</td><td>均匀杂波背景</td><td>在杂波边缘会引起虚警率的上升；多目标环境中的检测性能较差。</td></tr><tr><td>SO-CFAR</td><td>min{X, Y}</td><td>在干扰目标位于前沿或后沿滑窗之一的多目标环境中能分辨出主目标。</td><td>杂波边缘和均匀杂波环境中的检测性能较差。</td></tr><tr><td>GO-CFAR</td><td>max{X, Y}</td><td>在杂波边缘和均匀杂波环境能保持较好的检测性能。</td><td>多目标环境中的检测性能较差。</td></tr><tr><td>OS-CFAR</td><td>(ascend_sort{X, Y})</td><td>多目标检测性能较好。</td><td>依赖于参考窗内的所有样本数据，且 k 的取值直接决定了检测结果的优劣。</td></tr></tbody></table><p>一维CFAR检测流程图如下所示</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9bdf49.png" alt="1d-cafr.png"></p><h2 id="二、距离多普勒矩阵（Range-Doppler-Matrix，RDM">二、距离多普勒矩阵（Range-Doppler Matrix，RDM)</h2><p>在检测过程中，除了要知道到目标的距离信息以外，还要知道目标的速度信息，因此1D-CFAR不再满足我们的要求，而是需要采用2D-CAFR。而2D-CAFR处理的对象就是距离多普勒矩阵（Range-Doppler Matrix），RDM的形成过程如下所示</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d43961.png" alt="RDM.png"></p><p>2D-CFAR是对两个维度同时检测，</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9f14e8.png" alt="2d-cfar.png"></p><p>还有一种方法是两次CFAR，即先对某一个维度做一次，然后又对另一个维度做一次，总共两次CFAR。比如先对速度维做一次CA-CFAR，然后对距离维做一次OS-CFAR，如图7所示。这样做的目的可以减少计算量，节约计算时间。因为当检测出具有速度的目标后，只针对动目标检测要比检测全部元素点要快速。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9ed382.png" alt="2d-cfar2.png"></p><h2 id="三、二维CFAR（2D-CFAR）算法原理与仿真">三、二维CFAR（2D-CFAR）算法原理与仿真</h2><p>前面阐述了一些概念性内容，下面是本文的核心部分。</p><p>如图所示，是2D-CFAR的原理模型。我们可以设计一个循环程序，通过在参考单元和保护单元的边缘提供边距，使 CUT 在距离多普勒图上滑动。对于每次迭代，求所有参考单元中所有信号电平的和并取平均。接下来，将 CUT （被检测单元）下的信号与此阈值进行比较。如果CUT &gt; 阈值，则认为是目标信号，并为其分配值 1，否则认为是噪声信号，并将其置为0。（类似神经网络里的conv2D有木有？）</p><p>上述过程将生成一个阈值块，如图中绿色和红色组成的区域。因为 CUT 不能位于RDM谱矩阵的边缘，故而该阈值块小于距离多普勒图， 因此存在一部分点不会被检测到，但需要对这部分未检测到的点进行处理，关于这个问题后面会讨论。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d42c23.png" alt="2d-cfar3.png"></p><h2 id="四、仿真">四、仿真</h2><ol><li>生成FMCW信号</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% FMCW 波形生成</span></span><br><span class="line"></span><br><span class="line">B = c /(<span class="number">2</span>*range_resolution);       <span class="comment">%带宽</span></span><br><span class="line">Tchirp= (<span class="number">5.5</span>*<span class="number">2</span>*max_range)/c;       <span class="comment">%计算 Chirp 时间（5.5 倍往返时间）</span></span><br><span class="line">slope = B/Tchirp;                  <span class="comment">%FMCW斜率</span></span><br><span class="line"><span class="built_in">disp</span>(slope);                       <span class="comment">% 显示斜率</span></span><br><span class="line">fc= <span class="number">1.5e3</span>;                         <span class="comment">%载波频率</span></span><br><span class="line">                                                          </span><br><span class="line"><span class="comment">% 一组 Chirp 信号的数量（建议使用 2 的幂次方以便 FFT 计算多普勒频谱）</span></span><br><span class="line">Nd=<span class="number">128</span>;                            <span class="comment">% 多普勒维度（即 Chirp 数量）</span></span><br><span class="line"><span class="comment">%每个chirp的采样数</span></span><br><span class="line">Nr=<span class="number">1024</span>;                           <span class="comment">% 距离维度（即每个 Chirp 的采样点数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 时间向量，覆盖所有 Chirp 和每个 Chirp 内的样本</span></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,Nd*Tchirp,Nr*Nd);     <span class="comment">% 生成总时间轴</span></span><br></pre></td></tr></table></figure><ol start="2"><li>信号生成与移动目标仿真</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(t)         </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% *%TODO* :</span></span><br><span class="line">    <span class="comment">% 根据时间步长更新目标的距离 (匀速运动)</span></span><br><span class="line">    <span class="comment">% r(t) = r0 + v*t</span></span><br><span class="line">    r_t(<span class="built_in">i</span>) = target_range+ target_velocity*t(<span class="built_in">i</span>); <span class="comment">% 目标当前距离</span></span><br><span class="line">    td(<span class="built_in">i</span>) = <span class="number">2</span>*r_t(<span class="built_in">i</span>)/c;                          <span class="comment">% 计算信号往返时间延迟</span></span><br><span class="line">    <span class="comment">% <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">% 为每个时间点生成发射和接收信号</span></span><br><span class="line">    <span class="comment">% 发射信号 Tx：FMCW 信号的基本公式</span></span><br><span class="line">    Tx(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(fc*t(<span class="built_in">i</span>) + (slope*t(<span class="built_in">i</span>)^<span class="number">2</span>)/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 接收信号 Rx：考虑了往返延迟的 FMCW 信号</span></span><br><span class="line">    Rx(<span class="built_in">i</span>) = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(fc*(t(<span class="built_in">i</span>)-td(<span class="built_in">i</span>)) + (slope*(t(<span class="built_in">i</span>)-td(<span class="built_in">i</span>))^<span class="number">2</span>)/<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">% 生成混频信号（打拍频信号）</span></span><br><span class="line">    <span class="comment">% 将发射信号和接收信号逐元素相乘</span></span><br><span class="line">    Mix(<span class="built_in">i</span>) = Tx(<span class="built_in">i</span>).*Rx(<span class="built_in">i</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>距离-多普勒响应 (RDM)</strong></li></ol><p>该部分实现了 2D FFT，用于生成距离-多普勒图 (RDM)。 后续可以基于该 RDM 进行 CFAR 检测。</p><p>二维 FFT 的输出是一个包含距离和多普勒频移响应的图像，其坐标轴单位最初是FFT bin（频率单元格）。 因此，为了直观反映目标的实际距离和速度， 需要根据最大取值将坐标轴从 bin 索引转换为实际的距离 (m) 和多普勒速度 (m/s)。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 将混频信号重塑为 Nr × Nd 矩阵</span></span><br><span class="line">Mix=<span class="built_in">reshape</span>(Mix,[Nr,Nd]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对打拍频信号执行二维 FFT（分别在距离和多普勒维度上）</span></span><br><span class="line">sig_fft2 = fft2(Mix,Nr,Nd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 仅保留距离维度的单边谱</span></span><br><span class="line">sig_fft2 = sig_fft2(<span class="number">1</span>:Nr/<span class="number">2</span>,<span class="number">1</span>:Nd);</span><br><span class="line"></span><br><span class="line">sig_fft2 = fftshift(sig_fft2);<span class="comment">% 对多普勒维度做 fftshift，使零频分量居中</span></span><br><span class="line">RDM = <span class="built_in">abs</span>(sig_fft2);        <span class="comment">% 计算幅度并转换为 dB 值</span></span><br><span class="line">RDM = <span class="number">10</span>*<span class="built_in">log10</span>(RDM) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">% ---------------------</span></span><br><span class="line"><span class="comment">% 绘制距离-多普勒图 (RDM)</span></span><br><span class="line"><span class="comment">% ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义多普勒和距离坐标轴</span></span><br><span class="line">doppler_axis = <span class="built_in">linspace</span>(<span class="number">-100</span>,<span class="number">100</span>,Nd);             <span class="comment">% 多普勒频移轴（-100 ~ 100 m/s）</span></span><br><span class="line">range_axis = <span class="built_in">linspace</span>(<span class="number">-200</span>,<span class="number">200</span>,Nr/<span class="number">2</span>)*((Nr/<span class="number">2</span>)/<span class="number">400</span>);<span class="comment">% 距离轴</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">surf(doppler_axis,range_axis,RDM);</span><br><span class="line">xlabel(<span class="string">&#x27;doppler&#x27;</span>);ylabel(<span class="string">&#x27;range&#x27;</span>);zlabel(<span class="string">&#x27;RDM&#x27;</span>);title(<span class="string">&#x27;2D FFT&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>CFAR 检测</strong></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%在RDM上窗口滑动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择训练单元 (Training Cells) 的数量</span></span><br><span class="line">Tr = <span class="number">8</span>; <span class="comment">% 距离维度上的训练单元数量</span></span><br><span class="line">Td = <span class="number">4</span>; <span class="comment">% 多普勒维度上的训练单元数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 选择保护单元 (Guard Cells) 的数量，围绕 CUT 以避免信号泄漏</span></span><br><span class="line">Gr = <span class="number">4</span>; <span class="comment">% 距离维度上的保护单元数量</span></span><br><span class="line">Gd = <span class="number">2</span>; <span class="comment">% 多普勒维度上的保护单元数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">% 设置SNR偏移量 (以dB为单位)，用于调整检测灵敏度</span></span><br><span class="line">offset = <span class="number">1.4</span>;</span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">%初始化一个向量来存储训练单元每个 iteration 的噪声级</span></span><br><span class="line">noise_level = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">% 设计一个循环，使 “CUT” 在距离 - 多普勒图上滑动，同时在边缘处为训练单元和保护单元留出边界。</span></span><br><span class="line"><span class="comment">% 对于每次迭代，将所有训练单元内的信号电平进行求和。为了求和，需使用 db2pow 函数将数值从对数形式转换为线性形式。</span></span><br><span class="line"><span class="comment">% 对所使用的所有训练单元的求和值求平均。求平均后，再使用 pow2db 函数将其转换回对数形式。</span></span><br><span class="line"><span class="comment">% 进一步给它加上偏移量以确定阈值。接下来，将 “CUT” 下的信号与该阈值进行比较。</span></span><br><span class="line"><span class="comment">% 如果 “CUT” 的电平 &gt; 阈值，则赋予其值为 1，否则将其设为 0。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">% Use RDM[x,y] as the matrix from the output of 2D FFT for implementing</span></span><br><span class="line">   <span class="comment">% CFAR</span></span><br><span class="line"></span><br><span class="line">RDM = RDM/<span class="built_in">max</span>(<span class="built_in">max</span>(RDM));</span><br><span class="line"> <span class="comment">%滑动窗口遍历整个RDM</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = Tr+Gr+<span class="number">1</span> : Nr/<span class="number">2</span>-(Gr+Tr)    <span class="comment">% 遍历距离维度</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = Td+Gd+<span class="number">1</span> : Nd-(Gd+Td)  <span class="comment">% 遍历多普勒维度</span></span><br><span class="line"></span><br><span class="line">        noise_level = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">1</span>);  <span class="comment">% 初始化当前窗口的噪声能量</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> p = <span class="built_in">i</span>-(Tr+Gr): <span class="built_in">i</span>+ (Tr+Gr) <span class="comment">% 遍历当前CUT周围的训练单元和保护单元</span></span><br><span class="line">            <span class="keyword">for</span> q = <span class="built_in">j</span>-(Td+Gd): <span class="built_in">j</span>+(Td+Gd)</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">i</span>-p)&gt; Gr ||<span class="built_in">abs</span>(<span class="built_in">j</span>-q)&gt;Gd)<span class="comment">% 排除保护单元，只计算训练单元的能量</span></span><br><span class="line">                   <span class="comment">% 将dB值转换为线性功率值</span></span><br><span class="line">                    noise_level = noise_level+ db2pow(RDM(p,q));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 平均训练单元能量并转换回dB</span></span><br><span class="line">        threshold = pow2db(noise_level/(<span class="number">2</span>*(Td+Gd+<span class="number">1</span>)*<span class="number">2</span>*(Tr+Gr+<span class="number">1</span>)-(Gr*Gd)<span class="number">-1</span>));</span><br><span class="line">        threshold = threshold + offset;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 进行检测：若CUT大于阈值，标记为目标（1），否则为噪声（0）</span></span><br><span class="line">        CUT= RDM(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">if</span> (CUT&lt;threshold)</span><br><span class="line">            RDM(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            RDM(<span class="built_in">i</span>,<span class="built_in">j</span>)= <span class="number">1</span>; <span class="comment">% max_T</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line">            <span class="built_in">disp</span>(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 上述过程将生成一个经过阈值处理的块，该块比距离 - 多普勒图小，</span></span><br><span class="line"><span class="comment">% 因为 “CUT” 不能位于矩阵的边缘。因此，有少量单元不会经过阈值处理。</span></span><br><span class="line"><span class="comment">% 为了保持地图大小不变，将这些单元的值设为 0。</span></span><br><span class="line"></span><br><span class="line">RDM(RDM~=<span class="number">0</span> &amp; RDM~=<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">%RDM(union(1:(Tr+Gr),end-(Tr+Gr-1):end),:) = 0;  % Rows</span></span><br><span class="line"><span class="comment">%RDM(:,union(1:(Td+Gd),end-(Td+Gd-1):end)) = 0;  % Columns</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% *%TODO* :</span></span><br><span class="line"><span class="comment">%绘制CFAR输出</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;CFAR&#x27;</span>)</span><br><span class="line">surf(doppler_axis,range_axis,RDM);</span><br><span class="line">colorbar;</span><br><span class="line">title(<span class="string">&#x27;offset 1.4&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续内容待补充……</p><p>完整代码：<a href="https://github.com/Vanillaholic/2D-CFAR-detection-of-FMCW">https://github.com/Vanillaholic/2D-CFAR-detection-of-FMCW</a></p><p>(本文只是学习笔记，侵删)参考：</p><p>[1] <a href="https://mp.weixin.qq.com/s/Gs8xTeQt5dtY8jMBfZ2xYA">https://mp.weixin.qq.com/s/Gs8xTeQt5dtY8jMBfZ2xYA</a></p><p>[2] <a href="https://mp.weixin.qq.com/s/iC18AWIRj6jOnR8SJMbpZw">https://mp.weixin.qq.com/s/iC18AWIRj6jOnR8SJMbpZw</a></p><!--stackedit_data:eyJoaXN0b3J5IjpbMjc5NjAyMDE1XX0=-->]]></content>
    
    
    <summary type="html">二维的恒虚警检测器CFAR ,用来探测目标移动速度和距离。</summary>
    
    
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="CFAR" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/CFAR/"/>
    
    
    <category term="雷达/声纳" scheme="https://vanillaholic.github.io/tags/%E9%9B%B7%E8%BE%BE-%E5%A3%B0%E7%BA%B3/"/>
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>恒虚警检测器CFAR</title>
    <link href="https://vanillaholic.github.io/2025/02/24/%E6%81%92%E8%99%9A%E8%AD%A6%E6%A3%80%E6%B5%8B%E5%99%A8CFAR/"/>
    <id>https://vanillaholic.github.io/2025/02/24/%E6%81%92%E8%99%9A%E8%AD%A6%E6%A3%80%E6%B5%8B%E5%99%A8CFAR/</id>
    <published>2025-02-24T11:16:00.000Z</published>
    <updated>2025-02-28T18:25:23.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述">一、概述</h2><p>雷达的检测过程可用门限检测来描述。几乎所有的判断都是以接收机的输出与某个门限电平的比较为基础的，如果接收机输出的包络超过了某一设置门限，就认为出现了目标。<br>雷达在探测时会受到噪声、杂波和干扰的影响，因而采用固定门限进行目标检测时会产生一定的虚警，特别是当杂波背景起伏变化时虚警率会急剧上升，严重影响雷达的检测性能。因此，根据雷达杂波数据动态调整检测门限，在虚警概率保持不变的情况下实现目标检测概率最大化，这种方法称为<strong>恒虚警率（Constant False Alarm Rate，CFAR）检测技术</strong>。</p><ul><li>虚警：在没有目标时判断为有目标（没有-&gt;有）</li><li>漏警：在有目标时判断为没有目标（有-&gt;没有）</li></ul><h2 id="二、CFAR检测算法">二、CFAR检测算法</h2><h3 id="1-基本原理">1.基本原理</h3><p>在实际工作过程中，将信号与阈值进行比较来判断信号的有无，这个阈值的计算就用到了检测概率和虚警概率、漏警概率。对于声纳系统的来说，<strong>阈值的选择目的在于保证最大化的检测概率以及虚警概率小于一定的量级。</strong></p><p>在CFAR中，检测需要一个指定的距离单元，常被成为被，称为检测单元(CUT, cell under test)，噪声功率根据临近的距离单元得到。检测的阈值为T，有如下表达式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><mi>a</mi><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T=aP_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>P_n表示噪声功率估计，a是缩放因子，选取一个合适的因子，虚警概率就可以保持为一个常数，因此该方法称为CFAR。</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d1657b.png" alt="CFAR-TH.png"></p><p>阈值随着信号的噪声功率增加，以保持恒定的虚警率。当信号水平超过阈值时，会发生检测。</p><h3 id="2-典型的CFAR算法">2.典型的CFAR算法</h3><h5 id="2-1-均值类CFAR-CA-CFAR-算法">2.1 均值类CFAＲ(CA-CFAＲ)算法</h5><p>一维情况如下所示：</p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0c72f26.png" alt="CFAR.png"></p><p><img src="https://www.helloimg.com/i/2025/02/26/67be7bf9bdf49.png" alt="1d-cafr.png"></p><p>最中间的检测单元，其次是守护单元(保护单元主要用在单目标情况下，防止目标能量泄漏到参考单元影响检测效果)，最外围是训练单元，噪声估计可以计算为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>N</mi></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>N</mi></mrow></munderover><msub><mi>x</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">P_n = \frac{1}{2N} \sum_{m=1}^{2N} x_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0954em;vertical-align:-1.2671em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，训练单元的长度为2N，x是训练单元中的样本[1]</p><blockquote><p>With the above cell averaging CFAR detector, assuming the data passed into the detector is from a single pulse, i.e., no pulse integration involved, the threshold factor can be written as [1]<br>使用上述单元平均 CFAR 检测器，假设传入检测器的数据来自单个脉冲，即不涉及脉冲积分，阈值因子可以写为 [1]</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2</mn><mi>N</mi><mo stretchy="false">(</mo><msubsup><mi>P</mi><mrow><mi>f</mi><mi>a</mi></mrow><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mi>N</mi></mrow></msubsup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha = 2N( P_{fa}^{-1/2N} - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4822em;vertical-align:-0.4374em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1/2</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4374em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>推导见[4]</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 距离测量 (Range Measurement)</span></span><br><span class="line"><span class="comment">% 将混频信号（Mix）重塑为 Nr x Nd 的矩阵</span></span><br><span class="line"><span class="comment">% Nr：距离维度（每个 Chirp 的采样点数）</span></span><br><span class="line"><span class="comment">% Nd：多普勒维度（Chirp 数量）</span></span><br><span class="line">sig = <span class="built_in">reshape</span>(Mix, [Nr, Nd]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 在距离维度 (Nr) 上对打拍频信号进行 FFT 变换</span></span><br><span class="line">sig_fft1 = fft(sig, Nr); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 对 FFT 结果进行归一化处理</span></span><br><span class="line">sig_fft1 = sig_fft1 ./ Nr;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 取 FFT 结果的幅值（只关注频谱强度）</span></span><br><span class="line">sig_fft1 = <span class="built_in">abs</span>(sig_fft1);</span><br><span class="line"></span><br><span class="line"><span class="comment">% FFT 结果是双边谱，只保留单边谱（正频率部分）</span></span><br><span class="line">sig_fft1 = sig_fft1(<span class="number">1</span>:(Nr/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制距离维度的 FFT 结果</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Range from First FFT&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制 1D FFT 输出，展示距离信息</span></span><br><span class="line"><span class="built_in">plot</span>(sig_fft1, <span class="string">&quot;LineWidth&quot;</span>,<span class="number">2</span>);</span><br><span class="line">grid on;axis ([<span class="number">0</span> <span class="number">200</span> <span class="number">0</span> <span class="number">0.5</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;range&#x27;</span>);ylabel(<span class="string">&#x27;FFT output&#x27;</span>);title(<span class="string">&#x27;1D FFT&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="2-2-最大选择GO-Greatest-Of-CFAR-最小选择SO-Smallest-Of-CFAR">2.2 最大选择GO(Greatest Of)-CFAR &amp;最小选择SO(Smallest Of)-CFAR</h5><p>最大选择就是选取前后n个训练单元之和进行对比，选取最大值作为噪声功率水平</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>Y</mi><mn>1</mn></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>Y</mi><mn>2</mn></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><msub><mi>X</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>G</mi><mi>O</mi><mo>:</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>Y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{l}Y_1 = \sum_{i=1}^{n} X_i \\Y_2 = \sum_{i=n+1}^{2n} X_i \\GO: \max(Y_1, Y_2)\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.714em;vertical-align:-1.607em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"/></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.107em;"><span style="top:-4.267em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.753em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">GO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.607em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>最小选择就是选取最小选择</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>Y</mi><mn>1</mn></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>Y</mi><mn>2</mn></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><msub><mi>X</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>S</mi><mi>O</mi><mo>:</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>Y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{l}Y_1 = \sum_{i=1}^{n} X_i \\Y_2 = \sum_{i=n+1}^{2n} X_i \\SO: \min(Y_1, Y_2)\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.714em;vertical-align:-1.607em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"/></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.107em;"><span style="top:-4.267em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.953em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.753em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">SO</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.607em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h5 id="2-3-有序统计类CFAR-OS-CFAR-算法">2.3 有序统计类CFAＲ(OS-CFAＲ)算法</h5><p>OS(Order Statistic)CFAR的原理是先对参考单元从小到大排序</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>o</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>k</mi><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>R</mi><mi>k</mi></mfrac><mo fence="true">)</mo></mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>T</mi><mo stretchy="false">)</mo><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">Γ</mi><mo stretchy="false">(</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex"> P_{fa, os} = k \binom{R}{k} \frac{\Gamma(R-k+1+T) \Gamma(k)}{\Gamma(R+1+T)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">os</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">Γ</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><em>R</em>=2<em>n</em>，k  为OS-CFAR中的参数，其值的选取对算法的检测性能有较大影响[3]。</p><h3 id="三、性能比较">三、性能比较</h3><table><thead><tr><th>CFAR 类型</th><th>参考电平 Z</th><th>适用场合</th><th>缺点</th></tr></thead><tbody><tr><td>CA-CFAR</td><td>(X+Y)/2</td><td>均匀杂波背景</td><td>在杂波边缘会引起虚警率的上升；多目标环境中的检测性能较差。</td></tr><tr><td>SO-CFAR</td><td>min{X, Y}</td><td>在干扰目标位于前沿或后沿滑窗之一的多目标环境中能分辨出主目标。</td><td>杂波边缘和均匀杂波环境中的检测性能较差。</td></tr><tr><td>GO-CFAR</td><td>max{X, Y}</td><td>在杂波边缘和均匀杂波环境能保持较好的检测性能。</td><td>多目标环境中的检测性能较差。</td></tr><tr><td>OS-CFAR</td><td>(ascend_sort{X, Y})</td><td>多目标检测性能较好。</td><td>依赖于参考窗内的所有样本数据，且 k 的取值直接决定了检测结果的优劣。</td></tr></tbody></table><p><img src="https://www.helloimg.com/i/2025/02/26/67be7c0d00b60.jpg" alt="CFAR_performance.jpg"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ------ 程序功能：四类CFAR检测算法的检测概率与SNR的关系 %</span></span><br><span class="line">clc</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">R = <span class="number">24</span>;                     <span class="comment">% 参考单元长度</span></span><br><span class="line">n = R/<span class="number">2</span>;                    <span class="comment">% 半滑窗长度</span></span><br><span class="line">k = R*<span class="number">3</span>/<span class="number">4</span>;                  <span class="comment">% os-cfar的参数</span></span><br><span class="line">P_fa = <span class="number">1e-6</span>;                <span class="comment">% 虚警概率</span></span><br><span class="line">SNR_dB = (<span class="number">0</span>:<span class="number">30</span>);            <span class="comment">% 信噪比</span></span><br><span class="line">SNR = <span class="number">10.</span>^(SNR_dB./<span class="number">10</span>);     <span class="comment">% 信号功率与噪声功率的比值</span></span><br><span class="line">syms T;                     <span class="comment">% 门限因子的符号变量</span></span><br><span class="line"><span class="comment">%% CA-CFAR</span></span><br><span class="line">T_CA = P_fa^(<span class="number">-1</span>/R)<span class="number">-1</span>;           <span class="comment">% CA-CFAR的门限因子</span></span><br><span class="line">Pd_CA = (<span class="number">1</span>+T_CA./(<span class="number">1</span>+SNR)).^(-R);    <span class="comment">% CA-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% SO-CFAR、GO-CFAR</span></span><br><span class="line">Pfa_SO = <span class="number">0</span>;</span><br><span class="line">syms T</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span>:n<span class="number">-1</span></span><br><span class="line">    Pfa_SO = Pfa_SO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">i</span>)*(<span class="number">2</span>+T)^(-(n+<span class="built_in">i</span>));     <span class="comment">% SO-CFAR的虚警概率表达式</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T1_SO = solve(Pfa_SO == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_SO = double(T1_SO);</span><br><span class="line">T_SO = T2_SO(T2_SO == <span class="built_in">abs</span>(T2_SO));      <span class="comment">% SO-CFAR的门限因子</span></span><br><span class="line"></span><br><span class="line">Pfa_GO = <span class="number">2</span>*(<span class="number">1</span>+T)^(-n)-Pfa_SO;           <span class="comment">% GO-CFAR的虚警概率表达式</span></span><br><span class="line">T1_GO = solve(Pfa_GO == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_GO = double(T1_GO);</span><br><span class="line">T_GO = T2_GO(T2_GO == <span class="built_in">abs</span>(T2_GO));      <span class="comment">% GO-CFAR的门限因子</span></span><br><span class="line"></span><br><span class="line">Pd_SO = <span class="number">0</span>;</span><br><span class="line">Pd_GO = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">0</span>:n<span class="number">-1</span></span><br><span class="line">    Pd_SO = Pd_SO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>).*(<span class="number">2</span>+T_SO./(<span class="number">1</span>+SNR)).^(-(n+<span class="built_in">j</span>));     <span class="comment">% SO-CFAR的检测概率</span></span><br><span class="line">    Pd_GO = Pd_GO+<span class="number">2</span>*<span class="built_in">nchoosek</span>(n+<span class="built_in">j</span><span class="number">-1</span>,<span class="built_in">j</span>).*(<span class="number">2</span>+T_GO./(<span class="number">1</span>+SNR)).^(-(n+<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Pd_GO = <span class="number">2.</span>*(<span class="number">1</span>+T_GO./(<span class="number">1</span>+SNR)).^(-n)-Pd_GO;         <span class="comment">% GO-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% OS-CFAR</span></span><br><span class="line">Pfa_OS = k*<span class="built_in">nchoosek</span>(R,k)*<span class="built_in">gamma</span>(R-k+<span class="number">1</span>+T)*<span class="built_in">gamma</span>(k)/<span class="built_in">gamma</span>(R+T+<span class="number">1</span>);           <span class="comment">% OS-CFAR的虚警概率表达式</span></span><br><span class="line">T1_OS = solve(Pfa_OS == P_fa, T);       <span class="comment">% 求解出虚警概率为P_fa时对应的门限因子T</span></span><br><span class="line">T2_OS = double(T1_OS);</span><br><span class="line">T_OS = T2_OS(T2_OS == <span class="built_in">abs</span>(T2_OS));      <span class="comment">% OS-CFAR的门限因子</span></span><br><span class="line">Pd_OS = k*<span class="built_in">nchoosek</span>(R,k)*<span class="built_in">gamma</span>(R-k+<span class="number">1</span>+T_OS./(<span class="number">1</span>+SNR))*<span class="built_in">gamma</span>(k)./<span class="built_in">gamma</span>(R+T_OS./(<span class="number">1</span>+SNR)+<span class="number">1</span>);      <span class="comment">% OS-CFAR的检测概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_CA,<span class="string">&#x27;r-*&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_SO,<span class="string">&#x27;k-^&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_GO,<span class="string">&#x27;b-o&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(SNR_dB,Pd_OS,<span class="string">&#x27;m-.&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;SNR&#x27;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;Time New Romans&#x27;</span>,<span class="string">&#x27;FontAngle&#x27;</span>,<span class="string">&#x27;italic&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;P_&#123;d&#125;&#x27;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;Time New Romans&#x27;</span>,<span class="string">&#x27;FontAngle&#x27;</span>,<span class="string">&#x27;italic&#x27;</span>);</span><br><span class="line">title([<span class="string">&#x27;恒虚警率 P_&#123;fa&#125;= &#x27;</span>,num2str(P_fa),<span class="string">&#x27;，参考单元 2n= &#x27;</span>,num2str(R)]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;CA&#x27;</span>,<span class="string">&#x27;SO&#x27;</span>,<span class="string">&#x27;GO&#x27;</span>,<span class="string">&#x27;OS&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="参考文献">参考文献</h3><p>[1] Mark Richards, <em>Fundamentals of Radar Signal Processing</em>, McGraw Hill, 2005</p><p>[2] 王蓓. 基于杂波图的恒虚警处理技术研究[D]. 西安电子科技大学, 2018.</p><p>[3] Detection loss due to interfering targets in ordered statistics CFAR.</p><p>[4] P. P. Gandhi and S. A. Kassam, “Analysis of CFAR processors in nonhomogeneous background,” in IEEE Transactions on Aerospace and Electronic Systems, vol. 24, no. 4, pp. 427-445, July 1988, doi: 10.1109/7.7185.<br>keywords: {Detectors;Radar detection;Degradation;Radar clutter;Senior members;Statistical distributions;Process design;Performance analysis;Clouds;Noise level},</p><!--stackedit_data:eyJoaXN0b3J5IjpbNTQwMTE0MjUwXX0=-->]]></content>
    
    
    <summary type="html">1维的恒虚警检测器CFAR</summary>
    
    
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    <category term="CFAR" scheme="https://vanillaholic.github.io/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/CFAR/"/>
    
    
    <category term="雷达/声纳" scheme="https://vanillaholic.github.io/tags/%E9%9B%B7%E8%BE%BE-%E5%A3%B0%E7%BA%B3/"/>
    
    <category term="信号处理" scheme="https://vanillaholic.github.io/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://vanillaholic.github.io/2024/05/20/hello-world/"/>
    <id>https://vanillaholic.github.io/2024/05/20/hello-world/</id>
    <published>2024-05-20T05:53:12.000Z</published>
    <updated>2025-02-28T18:29:25.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是我发的第一篇博客-以此证明我在这个世上存在过……">这是我发的第一篇博客,以此证明我在这个世上存在过……</h2><h2 id="如何发表文章">如何发表文章</h2><h3 id="安装hexo渲染器">安装hexo渲染器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><p>由于公式原因,需要更换渲染器里的东西,开启KaTeX 需要把 use 设置为 katex</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="comment"># Enable the copy KaTeX formula</span></span><br><span class="line">  <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>你不需要添加 katex.min.js 來渲染数学方程。相应的你需要卸載你之前的 hexo 的 markdown 渲染器，然后安装其它插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 如果有安装这个的话，卸载</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 如果有安装这个的话，卸载</span></span><br><span class="line"></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 需要安装这个渲染插件</span></span><br><span class="line">npm install katex @renbaoshuo/markdown-it-katex <span class="comment">#需要安装这个katex插件</span></span><br></pre></td></tr></table></figure><p>在 hexo 的根目录的 _config.yml 中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;@renbaoshuo/markdown-it-katex&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!--stackedit_data:eyJoaXN0b3J5IjpbMTkyNDkxNjgxM119-->]]></content>
    
    
    <summary type="html">我的第一篇博客</summary>
    
    
    
    
  </entry>
  
</feed>
